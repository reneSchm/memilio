<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEmilio: MEmilio C++ IO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MEmilio
   &#160;<span id="projectnumber">0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">MEmilio C++ IO </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This directory contains utilities for reading and writing data from and to files in different formats. The main part is a serialization framework that can be used to define the structure of data without using a specific file format. There are implementations of the framework for different formats. The framework is described in detail below, also see the <a href="../../examples/serialize.cpp">serialization example</a>.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
The Serialization framework</h1>
<h1><a class="anchor" id="autotoc_md14"></a>
Main functions and types:</h1>
<ul>
<li>functions serialize and deserialize: Main entry points to the framework to write and read values, respectively. The functions expect an IOContext (see Concepts below) that stores the serialized data. (De-)serialization can be customized by providing a (de-)serialize_internal overload or a (de-)serialize member function for the type. See the section "Implementing 
     serialization for a new type" or the documentation for <code>serialize</code> and <code>deserialize</code>.</li>
<li>IOStatus and IOResult: Used for error handling, see section "Error Handling" below.</li>
</ul>
<h1><a class="anchor" id="autotoc_md15"></a>
Concepts:</h1>
<ol type="1">
<li>IOContext Stores data that describes serialized objects of any type in some unspecified format and provides structured access to the data for deserialization. Implementations of this concept may store the data in any format they want including binary. The data may also be written directly to disk. The context also keeps track of errors. An IOContext object <code>io</code> allows the following operations:</li>
</ol>
<ul>
<li><code>io.create_object("Type")</code>: Returns an IOObject for the type called <code>"Type"</code>. The IOObject (see below) allows adding data that describes the object to be serialized. The function must return something that can be assigned to a local variable, e.g., a temporary or copyable function. IOObject may store references to the context internally, so the lifetime of the local IOObject may not exceed the lifetime of the IOContext that created it.</li>
<li><code>io.expect_object("Type")</code>: Returns an IOObject for the type called <code>"Type"</code>. The IOObject (see below) provides access to the data needed for deserialization.</li>
<li><code>io.flags()</code>: Returns the flags that determine the behavior of serialization; see IOFlags.</li>
<li><code>io.error()</code>: Returns an IOStatus object to check if there were any errors during serialization. Usually it is not necessary to check this manually but can be used to report the error faster and avoid expensive operations that would be wasted anyway.</li>
<li><code>io.set_error(s)</code> with some IOStatus object: Stores an error that was generated outside of the IOContext, e.g., if a value that was deserialized is outside an allowed range.</li>
</ul>
<ol type="1">
<li>IOObject Gives structured access to serialized data. During serialization, data can be added with <code>add_...</code> operations. During deserialization, data can be retrieved with <code>expect_...</code> operations. Data must be retrieved in the same order as it was added since, e.g., binary format does not allow lookup by key. The following operations are supported for an IOObject <code>obj</code>:</li>
</ol>
<ul>
<li><code>obj.add_element("Name", t)</code>: Stores an object <code>t</code> in the IOObject under the key "Name". If <code>t</code> is of basic type (i.e., int, string), IOObject is expected to handle it directly. Otherwise, the object uses <code><a class="el" href="namespacemio.html#a27a24b9e6cb629e04e9613446f07d6ba" title="Save data that describes an object in a format determined by the given context.">mio::serialize</a></code> to get the data for <code>t</code>.</li>
<li><code>obj.add_list("Name", b, e)</code>: Stores the elements in the range represented by iterators <code>b</code> and <code>e</code> under the key "Name". The individual elements are not named. The elements are either handled directly by the IOObject or using <code><a class="el" href="namespacemio.html#a27a24b9e6cb629e04e9613446f07d6ba" title="Save data that describes an object in a format determined by the given context.">mio::serialize</a></code> just like <code>add_element</code>.</li>
<li><code>obj.add_optional("Name", p)</code>: Stores the element pointed to by pointer <code>p</code> under the key "Name". The pointer may be null. Otherwise identical to add_element.</li>
<li><code>obj.expect_element("Name", Tag&lt;T&gt;{})</code>: If an object of type T can be found under the key "Name" and can be deserialized, returns the object. Otherwise returns an error. Analogously to serialization, the IOObject is expected to handle basic types directly and use <code><a class="el" href="namespacemio.html#a1eecf99ef3a231d628f968aeb2136865" title="Restores an object from the data stored in an IO context.">mio::deserialize</a></code> otherwise.</li>
<li><code>obj.expect_list("Name", Tag&lt;T&gt;{})</code>: If a list of objects of type T can be found under the key "Name" and can be deserialized, returns a range that can be iterated over. Otherwise returns an error.</li>
<li><code>obj.expect_optional("Name", Tag&lt;T&gt;{})</code>: Returns boost::optional&lt;T&gt; if an optional value of type T can be found under the key "Name". The optional may contain a value or it may be empty. Otherwise returns an error. Note that for some formats a wrong key is indistinguishable from an empty optional, so make sure to provide the correct key.</li>
</ul>
<h1><a class="anchor" id="autotoc_md16"></a>
Error handling:</h1>
<p>Errors are handled by returning error codes. The type IOStatus contains an error code and an optional string with additional information. The type IOResult contains either a value or an IOStatus that describes an error. Operations that can fail return an IOResult&lt;T&gt; where T is the type of the value that is produced by the operation if it is succesful. Except where necessary because of dependencies, the framework does not throw nor catch any exceptions. IOContext and IOObject implementations are expected to store errors. During serialization, <code>add_...</code> operations fail without returning errors, but the error is stored in the IOObject and subsequent calls are usually no-ops. During deserialization, the values produced must usually be used or inspected, so <code>expect_...</code> operations return an IOResult. The <code>apply</code> utility function provides a simple way to inspect the result of multiple <code>expect_...</code> operations and use the values if all are succesful. See the documentation of <code>IOStatus</code>, <code>IOResult</code> and <code>apply</code> below for more details.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Adding a new data type to be serialized:</h1>
<p>Serialization of a new type T can be customized by providing <em>either</em> member functions <code>serialize</code> and <code>deserialize</code> <em>or</em> free functions <code>serialize_internal</code> and <code>deserialize_internal</code>.</p>
<p>The <code>void serialize(IOContext&amp; io)</code> member function takes an IO context and uses <code>create_object</code> and <code>add_...</code> operations to add data. The static <code>IOResult&lt;T&gt; deserialize(IOContext&amp; io)</code> member function takes an IO context and uses <code>expect_...</code> operations to retrieve the data. The <code>apply</code> utility function can be used to inspect the result of the <code>expect_...</code> operations and construct the object of type T. E.g.: </p><div class="fragment"><div class="line">struct Foo {</div>
<div class="line">  int i;</div>
<div class="line">  template&lt;class IOContext&gt;</div>
<div class="line">  void serialize(IOContext&amp; io) {</div>
<div class="line">    auto obj = io.create_object(&quot;Foo&quot;);</div>
<div class="line">    obj.add_element(&quot;i&quot;, i);</div>
<div class="line">  }</div>
<div class="line">  template&lt;class IOContext&gt;</div>
<div class="line">  static IOResult&lt;Foo&gt; deserialize(IOContext&amp; io) {</div>
<div class="line">    auto obj = io.expect_object(&quot;Foo&quot;);</div>
<div class="line">    auto i_result = obj.expect_element(&quot;i&quot;, mio::Tag&lt;int&gt;{});</div>
<div class="line">    return mio::apply(io, [](auto&amp;&amp; i) { return Foo{i}; }, i_result);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The free functions <code>serialize_internal</code> and <code>deserialize_internal</code> must be found with argument dependent lookup (ADL). They can be used if no member function should or can be added to the type. See the code below for examples where this was done for, e.g., Eigen3 matrices and STL containers.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Adding a new format:</h1>
<p>Implement concepts IOContext and IOObject that provide the operations listed above. Your implemenation should handle all built in types as well as std::string. It may handle other types (e.g., STL containers) as well if it can do so more efficiently than the provided general free functions.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Other IO modules</h1>
<ul>
<li>HDF5 support classes for C++</li>
<li>Reading of mobility matrix files</li>
</ul>
<h1><a class="anchor" id="autotoc_md20"></a>
The command line interface</h1>
<p>We provide a function <code>mio::command_line_interface</code> in the header <code><a class="el" href="cli_8h.html">memilio/io/cli.h</a></code>, that can be used to write to or read from a parameter set. It can take parameters from command line arguments (i.e. the content of <code>argv</code> in the main function), and assign them to or get them from a <code><a class="el" href="classmio_1_1ParameterSet.html" title="a set of parameters defined at compile time">mio::ParameterSet</a></code>. A small example can be seen in <code>cpp/examples/cli.cpp</code>.</p>
<p>The command line interface (CLI) provides a help dialogue that can be invoked by the argument <code>--help</code> or <code>-h</code>, and the option <code>--print_option</code>. The help option shows the basic usage of the CLI, and lists each parameter by name, as well as any alias and description. "--print_option" can be used with a (space seperated) list of parameter names or aliases (without dashes) to print the current values each parameter to the terminal. In general, an option is defined as a string, which consists either of two dashes followed by a parameter name (e.g. &ndash;help), or a single dash followed by its alias (e.g. -h).</p>
<p>To set the value of a parameter from the command line, first type the corresponding option (see &ndash;help), followed by the value that should be assigned (reference &ndash;print_option). Values are given as a Json value corresponding to the Type of the parameter. Note that some characters may need to be escaped or quoted, e.g. the Json string <code>"some string"</code> must be entered as <code>\"some string\\"</code> or &lsquo;&rsquo;"some string"'`. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
