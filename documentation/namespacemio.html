<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEmilio: mio Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MEmilio
   &#160;<span id="projectnumber">0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mio Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of classes to simplify handling of matrix shapes in meta programming.  
<a href="namespacemio.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemio_1_1abm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio_1_1abm.html">abm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemio_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemio_1_1details"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio_1_1details.html">details</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemio_1_1isecir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio_1_1isecir.html">isecir</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemio_1_1iseir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio_1_1iseir.html">iseir</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemio_1_1mpi"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio_1_1mpi.html">mpi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemio_1_1osecir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio_1_1osecir.html">osecir</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemio_1_1osecirvvs"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio_1_1osecirvvs.html">osecirvvs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemio_1_1oseir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio_1_1oseir.html">oseir</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemio_1_1regions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio_1_1regions.html">regions</a></td></tr>
<tr class="memdesc:namespacemio_1_1regions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains utilities that depend on geographical regions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1AgeGroup.html">AgeGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structmio_1_1AgeGroup.html" title="The AgeGroup struct is used as a dynamically sized tag for all age dependent categories.">AgeGroup</a> struct is used as a dynamically sized tag for all age dependent categories.  <a href="structmio_1_1AgeGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1BinarySerializerContext.html">BinarySerializerContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes objects in binary format.  <a href="classmio_1_1BinarySerializerContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1BinarySerializerObject.html">BinarySerializerObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a binary serialized object.  <a href="classmio_1_1BinarySerializerObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1ByteStream.html">ByteStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-memory stream of bytes.  <a href="classmio_1_1ByteStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1ColumnVectorShape.html">ColumnVectorShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">shape of a column vector.  <a href="classmio_1_1ColumnVectorShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1CompartmentalModel.html">CompartmentalModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmio_1_1CompartmentalModel.html" title="CompartmentalModel is a template for a compartmental model for an array of initial populations and a ...">CompartmentalModel</a> is a template for a compartmental model for an array of initial populations and a parameter set.  <a href="structmio_1_1CompartmentalModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1conjunction.html">conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">conjunction (logical and) of zero or more type traits with boolean values.  <a href="structmio_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1conjunction_3_01B1_01_4.html">conjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1conjunction_3_01B1_00_01Bn_8_8_8_01_4.html">conjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1ConstantFunction.html">ConstantFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that defines a constant function.  <a href="structmio_1_1ConstantFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1ConstVisitor.html">ConstVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1ConstVisitor_3_01T_01_4.html">ConstVisitor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1ConstVisitor_3_01T_00_01Types_8_8_8_01_4.html">ConstVisitor&lt; T, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1ContactMatrix.html">ContactMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents time dependent contact frequencies between groups.  <a href="classmio_1_1ContactMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1ContactMatrixGroup.html">ContactMatrixGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a collection of contact frequency matrices that whose sum is the total number of contacts.  <a href="classmio_1_1ContactMatrixGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1ControlledStepperWrapper.html">ControlledStepperWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and manages an instance of a boost::numeric::odeint::controlled_runge_kutta integrator, wrapped as <a class="el" href="classmio_1_1IntegratorCore.html">mio::IntegratorCore</a>.  <a href="classmio_1_1ControlledStepperWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1CustomIndexArray.html">CustomIndexArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template for an array with custom indices.  <a href="classmio_1_1CustomIndexArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1CVPlainMatrix.html">CVPlainMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper to get the matrix type from an eigen expression with correct const volatile qualitfications.  <a href="structmio_1_1CVPlainMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1CVPlainMatrix_3_01Eigen_1_1Ref_3_01const_01M_01_4_01_4.html">CVPlainMatrix&lt; Eigen::Ref&lt; const M &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1Damping.html">Damping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represent interventions or effects that affect contact frequencies between multiple groups.  <a href="classmio_1_1Damping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1DampingMatrixExpression.html">DampingMatrixExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the coefficient wise matrix (or vector) expression B - D * M where B is a baseline, M is a minimum and D is some time dependent complex damping factor.  <a href="classmio_1_1DampingMatrixExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1DampingMatrixExpressionGroup.html">DampingMatrixExpressionGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a collection of DampingMatrixExpressions that are summed up.  <a href="classmio_1_1DampingMatrixExpressionGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1Dampings.html">Dampings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">collection of dampings at different time points.  <a href="classmio_1_1Dampings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1DampingSampling.html">DampingSampling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">randomly sample dampings for e.g.  <a href="classmio_1_1DampingSampling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1DataWriterToMemory.html">DataWriterToMemory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1Date.html">Date</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple date representation as year, month, and day.  <a href="structmio_1_1Date.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1DiscreteDistributionInPlace.html">DiscreteDistributionInPlace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">select a random integer in [0, n) with weights [w_0, ..., w_(n-1)] the probability to pick i is w_i/S where S is the sum of all weights.  <a href="classmio_1_1DiscreteDistributionInPlace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1disjunction.html">disjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">disjunction (logical or) of zero or more type traits with boolean values.  <a href="structmio_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1disjunction_3_01B1_01_4.html">disjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1disjunction_3_01B1_00_01Bn_8_8_8_01_4.html">disjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1DistributionAdapter.html">DistributionAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">adapter for a random number distribution.  <a href="classmio_1_1DistributionAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1DynamicNPIs.html">DynamicNPIs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents non-pharmaceutical interventions (NPI) that are activated during the simulation if some value (e.g.  <a href="classmio_1_1DynamicNPIs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents an edge of the graph  <a href="structmio_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1EdgeBase.html">EdgeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1EulerIntegratorCore.html">EulerIntegratorCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple explicit euler integration y(t+1) = y(t) + h*f(t,y) for ODE y'(t) = f(t,y)  <a href="classmio_1_1EulerIntegratorCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1ExponentialDecay.html">ExponentialDecay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that defines an exponential decay function depending on the state age.  <a href="structmio_1_1ExponentialDecay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1Graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic graph structure  <a href="classmio_1_1Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1GraphSimulation.html">GraphSimulation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1GraphSimulationBase.html">GraphSimulationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract simulation on a graph with alternating node and edge actions  <a href="classmio_1_1GraphSimulationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1GraphSimulationStochastic.html">GraphSimulationStochastic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1History.html">History</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1Index.html">Index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmio_1_1Index.html" title="An Index with more than one template parameter combines several Index objects.">Index</a> with more than one template parameter combines several <a class="el" href="classmio_1_1Index.html" title="An Index with more than one template parameter combines several Index objects.">Index</a> objects.  <a href="classmio_1_1Index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1Index_3_01CategoryTag_01_4.html">Index&lt; CategoryTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmio_1_1Index.html" title="An Index with more than one template parameter combines several Index objects.">Index</a> with a single template parameter is a typesafe wrapper for size_t that is associated with a Tag.  <a href="classmio_1_1Index_3_01CategoryTag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1InEdgeBase.html">InEdgeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1IntegratorCore.html">IntegratorCore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1IOStatus.html">IOStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmio_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> represents the result of an operation.  <a href="classmio_1_1IOStatus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1is__dynamic__matrix.html">is_dynamic_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Eigen::Matrix type M is a dynamic matrix type.  <a href="structmio_1_1is__dynamic__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1is__dynamic__vector.html">is_dynamic_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Eigen::Matrix type M is a dynamic vector type.  <a href="structmio_1_1is__dynamic__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines static constant value = true if Expr&lt;T...&gt; produces a valid type.  <a href="structmio_1_1is__expression__valid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1LogAlways.html">LogAlways</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1LogOnce.html">LogOnce</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the migration between two nodes.  <a href="classmio_1_1MigrationEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1MigrationEdgeStochastic.html">MigrationEdgeStochastic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the migration between two nodes.  <a href="classmio_1_1MigrationEdgeStochastic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1MigrationParameters.html">MigrationParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters that influence migration.  <a href="classmio_1_1MigrationParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1MigrationParametersStochastic.html">MigrationParametersStochastic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters that influence migration.  <a href="classmio_1_1MigrationParametersStochastic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1negation.html">negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates a type trait.  <a href="structmio_1_1negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a node of the graph  <a href="structmio_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1NoDefaultInit.html">NoDefaultInit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag used for tag-dispatching the Constructor of <a class="el" href="classmio_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a>, triggering default initialization of all parameters using the get_default member function.  <a href="structmio_1_1NoDefaultInit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1observer__ptr.html">observer_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning pointer.  <a href="classmio_1_1observer__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1OdeIntegrator.html">OdeIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate initial value problems (IVP) of ordinary differential equations (ODE) of the form y' = f(y, t), y(t0) = y0.  <a href="classmio_1_1OdeIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1OperatorAdditionSubtraction.html">OperatorAdditionSubtraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class to add default operator +, +=, -, -= to a class derived from <a class="el" href="classmio_1_1TypeSafe.html" title="typesafe wrapper around any type to make function arguments, tuple elements, etc.">TypeSafe</a>.  <a href="classmio_1_1OperatorAdditionSubtraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1OperatorComparison.html">OperatorComparison</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class to add operator &lt;, &lt;=, &gt;, &gt;= to a class derived from <a class="el" href="classmio_1_1TypeSafe.html" title="typesafe wrapper around any type to make function arguments, tuple elements, etc.">TypeSafe</a>.  <a href="classmio_1_1OperatorComparison.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1OperatorIncrementDecrement.html">OperatorIncrementDecrement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class to add operator ++, &ndash; (pre- and post-) to a class derived from <a class="el" href="classmio_1_1TypeSafe.html" title="typesafe wrapper around any type to make function arguments, tuple elements, etc.">TypeSafe</a>.  <a href="classmio_1_1OperatorIncrementDecrement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1OperatorScalarMultiplicationDivision.html">OperatorScalarMultiplicationDivision</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class to add operator *, *=, /, /= with a scalar to a class derived from <a class="el" href="classmio_1_1TypeSafe.html" title="typesafe wrapper around any type to make function arguments, tuple elements, etc.">TypeSafe</a>.  <a href="classmio_1_1OperatorScalarMultiplicationDivision.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1OutEdgeBase.html">OutEdgeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1ParameterDistribution.html">ParameterDistribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1ParameterDistributionNormal.html">ParameterDistributionNormal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1ParameterDistributionUniform.html">ParameterDistributionUniform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1ParameterSet.html">ParameterSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a set of parameters defined at compile time  <a href="classmio_1_1ParameterSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1ParameterStudy.html">ParameterStudy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that performs multiple simulation runs with randomly sampled parameters.  <a href="classmio_1_1ParameterStudy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1ParameterTagTraits.html">ParameterTagTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the properties of a parameter  <a href="structmio_1_1ParameterTagTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1PointerDereferencingIterator.html">PointerDereferencingIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator adaptor that makes a range of T* look like a range of T e.g.  <a href="classmio_1_1PointerDereferencingIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1Populations.html">Populations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template for compartment populations.  <a href="classmio_1_1Populations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1RandomNumberGenerator.html">RandomNumberGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a uniform_random_bit_generator.  <a href="classmio_1_1RandomNumberGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">immutable random access range, e.g.  <a href="classmio_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1RectMatrixShape.html">RectMatrixShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">shape of a rectangular matrix.  <a href="classmio_1_1RectMatrixShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1RKIntegratorCore.html">RKIntegratorCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two scheme Runge-Kutta numerical integrator with adaptive step width.  <a href="classmio_1_1RKIntegratorCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterate over elements of eigen matrix expressions in row major order.  <a href="classmio_1_1RowMajorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1Seq.html">Seq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sequence of indices  <a href="structmio_1_1Seq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1SerializerBase.html">SerializerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for implementations of serialization framework concepts.  <a href="classmio_1_1SerializerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1Simulation.html">Simulation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the simulation of a compartment model.  <a href="classmio_1_1Simulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1SimulationDay.html">SimulationDay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the simulation time as an integer index.  <a href="classmio_1_1SimulationDay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the simulation in one node of the graph.  <a href="classmio_1_1SimulationNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1SimulationTime.html">SimulationTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">double simulation time.  <a href="classmio_1_1SimulationTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1SmootherCosine.html">SmootherCosine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that defines an smoother_cosine function depending on the state age.  <a href="structmio_1_1SmootherCosine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1Span.html">Span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a reference to any contigiuous array of objects.  <a href="classmio_1_1Span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1SquareMatrixShape.html">SquareMatrixShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">shape of a square matrix.  <a href="classmio_1_1SquareMatrixShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1StateAgeFunction.html">StateAgeFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function depending on the state age, i.e.  <a href="structmio_1_1StateAgeFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1StateAgeFunctionWrapper.html">StateAgeFunctionWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around <a class="el" href="structmio_1_1StateAgeFunction.html" title="A generic function depending on the state age, i.e.">StateAgeFunction</a> so that one can work with an arbitrary <a class="el" href="structmio_1_1StateAgeFunction.html" title="A generic function depending on the state age, i.e.">StateAgeFunction</a>.  <a href="structmio_1_1StateAgeFunctionWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1Tableau.html">Tableau</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two scheme Runge-Kutta numerical integrator with adaptive step width for ODE y'(t) = f(t,y) which is given by y_{n+1} = y_n + h*\sum_{i=1}^lb_ik_{ni} with k_{ni} = f(t_n + c_i*h, y_n + h*\sum_{j=1}^{i-1}a_{ij}k_{nj}) where the general Butcher tableau is 0 | c_2 | a_{21} c_3 | a_{31} a_{32} ...  <a href="classmio_1_1Tableau.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1TableauFinal.html">TableauFinal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores vectors of values at time points (or some other abstract variable) the value at each time point is a vector.  <a href="classmio_1_1TimeSeries.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1TimeSeriesTimeIterator.html">TimeSeriesTimeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over vector values of a time series by time point.  <a href="classmio_1_1TimeSeriesTimeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1TimeSeriesValueIterator.html">TimeSeriesValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over vector values of a time series by time point.  <a href="classmio_1_1TimeSeriesValueIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1TransformIterator.html">TransformIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator that transforms the values produced by an underlying iterator.  <a href="classmio_1_1TransformIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1TypeSafe.html">TypeSafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">typesafe wrapper around any type to make function arguments, tuple elements, etc.  <a href="classmio_1_1TypeSafe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1UncertainContactMatrix.html">UncertainContactMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmio_1_1UncertainContactMatrix.html" title="The UncertainContactMatrix class consists of a ContactMatrix with fixed baseline and uncertain Dampin...">UncertainContactMatrix</a> class consists of a <a class="el" href="classmio_1_1ContactMatrix.html" title="represents time dependent contact frequencies between groups.">ContactMatrix</a> with fixed baseline and uncertain <a class="el" href="classmio_1_1Dampings.html" title="collection of dampings at different time points.">Dampings</a>.  <a href="classmio_1_1UncertainContactMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmio_1_1UncertainValue.html">UncertainValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmio_1_1UncertainValue.html" title="The UncertainValue class consists of a scalar value and a Distribution object.">UncertainValue</a> class consists of a scalar value and a Distribution object.  <a href="classmio_1_1UncertainValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1Visitable.html">Visitable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1Visitor.html">Visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic visitor inspired by Fedor Pikus.  <a href="structmio_1_1Visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1Visitor_3_01T_01_4.html">Visitor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmio_1_1Visitor_3_01T_00_01Types_8_8_8_01_4.html">Visitor&lt; T, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af15ba49097f82eae310c5ed3d21a1b4b"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:af15ba49097f82eae310c5ed3d21a1b4b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#af15ba49097f82eae310c5ed3d21a1b4b">advance_expr_t</a> = decltype(std::declval&lt; Sim &gt;().advance(std::declval&lt; double &gt;()))</td></tr>
<tr class="memdesc:af15ba49097f82eae310c5ed3d21a1b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the return type of the <code>advance</code> member function of a type.  <a href="namespacemio.html#af15ba49097f82eae310c5ed3d21a1b4b">More...</a><br /></td></tr>
<tr class="separator:af15ba49097f82eae310c5ed3d21a1b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b64973f63b24b787e11ddbbb5f8dc3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#ad8b64973f63b24b787e11ddbbb5f8dc3">ConstParameterDistributionVisitor</a> = <a class="el" href="structmio_1_1ConstVisitor.html">ConstVisitor</a>&lt; class <a class="el" href="classmio_1_1ParameterDistributionNormal.html">ParameterDistributionNormal</a>, class <a class="el" href="classmio_1_1ParameterDistributionUniform.html">ParameterDistributionUniform</a> &gt;</td></tr>
<tr class="separator:ad8b64973f63b24b787e11ddbbb5f8dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d8d488db7199d4e87910999c8b30ec"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:af6d8d488db7199d4e87910999c8b30ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#af6d8d488db7199d4e87910999c8b30ec">CVPlainMatrixT</a> = typename <a class="el" href="structmio_1_1CVPlainMatrix.html">CVPlainMatrix</a>&lt; M &gt;::Type</td></tr>
<tr class="separator:af6d8d488db7199d4e87910999c8b30ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6164d4e8f4df5089a14e927650c5a638"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a6164d4e8f4df5089a14e927650c5a638">DerivFunction</a> = std::function&lt; void(Eigen::Ref&lt; const Eigen::VectorXd &gt; y, double t, Eigen::Ref&lt; Eigen::VectorXd &gt; dydt)&gt;</td></tr>
<tr class="memdesc:a6164d4e8f4df5089a14e927650c5a638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function template to be integrated.  <a href="namespacemio.html#a6164d4e8f4df5089a14e927650c5a638">More...</a><br /></td></tr>
<tr class="separator:a6164d4e8f4df5089a14e927650c5a638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc3cbccffee821ee8b3d10fceb36d1e"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T &gt; </td></tr>
<tr class="memitem:a8bc3cbccffee821ee8b3d10fceb36d1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a8bc3cbccffee821ee8b3d10fceb36d1e">deserialize_t</a> = decltype(T::deserialize(std::declval&lt; IOContext &amp; &gt;()))</td></tr>
<tr class="separator:a8bc3cbccffee821ee8b3d10fceb36d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650d53c2712e3249c7f9fdac228e664f"><td class="memTemplParams" colspan="2">template&lt;class Int &gt; </td></tr>
<tr class="memitem:a650d53c2712e3249c7f9fdac228e664f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a650d53c2712e3249c7f9fdac228e664f">DiscreteDistribution</a> = <a class="el" href="classmio_1_1DistributionAdapter.html">DistributionAdapter</a>&lt; <a class="el" href="classmio_1_1DiscreteDistributionInPlace.html">DiscreteDistributionInPlace</a>&lt; Int &gt; &gt;</td></tr>
<tr class="memdesc:a650d53c2712e3249c7f9fdac228e664f"><td class="mdescLeft">&#160;</td><td class="mdescRight">adapted discrete distribution  <a href="namespacemio.html#a650d53c2712e3249c7f9fdac228e664f">More...</a><br /></td></tr>
<tr class="separator:a650d53c2712e3249c7f9fdac228e664f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628e7270083870520c65318b8c5f2efd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a628e7270083870520c65318b8c5f2efd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a628e7270083870520c65318b8c5f2efd">eq_op_t</a> = decltype(std::declval&lt; T &gt;()==std::declval&lt; T &gt;())</td></tr>
<tr class="memdesc:a628e7270083870520c65318b8c5f2efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">meta function to check type T for an existing equality comparison operator  <a href="namespacemio.html#a628e7270083870520c65318b8c5f2efd">More...</a><br /></td></tr>
<tr class="separator:a628e7270083870520c65318b8c5f2efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dab8db023c553df90eb71275843f41"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a27dab8db023c553df90eb71275843f41"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a27dab8db023c553df90eb71275843f41">eval_right_hand_side_expr_t</a> = decltype(std::declval&lt; const M &amp; &gt;().eval_right_hand_side(std::declval&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt; &gt;(), std::declval&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt; &gt;(), std::declval&lt; double &gt;(), std::declval&lt; Eigen::Ref&lt; Eigen::VectorXd &gt; &gt;()))</td></tr>
<tr class="memdesc:a27dab8db023c553df90eb71275843f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect the eval_right_hand_side member function of a compartment model.  <a href="namespacemio.html#a27dab8db023c553df90eb71275843f41">More...</a><br /></td></tr>
<tr class="separator:a27dab8db023c553df90eb71275843f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4116647943793f9c44b5e2c70ea1a84e"><td class="memTemplParams" colspan="2">template&lt;class Real &gt; </td></tr>
<tr class="memitem:a4116647943793f9c44b5e2c70ea1a84e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a4116647943793f9c44b5e2c70ea1a84e">ExponentialDistribution</a> = <a class="el" href="classmio_1_1DistributionAdapter.html">DistributionAdapter</a>&lt; std::exponential_distribution&lt; Real &gt; &gt;</td></tr>
<tr class="memdesc:a4116647943793f9c44b5e2c70ea1a84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">adapted std::exponential_distribution.  <a href="namespacemio.html#a4116647943793f9c44b5e2c70ea1a84e">More...</a><br /></td></tr>
<tr class="separator:a4116647943793f9c44b5e2c70ea1a84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97757b3eaa1d1cd6fe1550f26c291bc5"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:a97757b3eaa1d1cd6fe1550f26c291bc5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a97757b3eaa1d1cd6fe1550f26c291bc5">get_infections_relative_expr_t</a> = decltype(<a class="el" href="namespacemio.html#a85ab6b99636fa04a3d21cb8d08fc4c08">get_infections_relative</a>(std::declval&lt; const Sim &amp; &gt;(), std::declval&lt; double &gt;(), std::declval&lt; const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp; &gt;()))</td></tr>
<tr class="memdesc:a97757b3eaa1d1cd6fe1550f26c291bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect a get_infections_relative function for the Model type.  <a href="namespacemio.html#a97757b3eaa1d1cd6fe1550f26c291bc5">More...</a><br /></td></tr>
<tr class="separator:a97757b3eaa1d1cd6fe1550f26c291bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861b27ba4067e505fdd45dec8087c169"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a861b27ba4067e505fdd45dec8087c169"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a861b27ba4067e505fdd45dec8087c169">get_initial_values_expr_t</a> = decltype(std::declval&lt; Eigen::VectorXd &amp; &gt;()=std::declval&lt; const M &amp; &gt;().get_initial_values())</td></tr>
<tr class="memdesc:a861b27ba4067e505fdd45dec8087c169"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect the get_initial_values member function of a compartment model.  <a href="namespacemio.html#a861b27ba4067e505fdd45dec8087c169">More...</a><br /></td></tr>
<tr class="separator:a861b27ba4067e505fdd45dec8087c169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bf290db560dfa35968e2b286ff078f"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:a55bf290db560dfa35968e2b286ff078f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a55bf290db560dfa35968e2b286ff078f">get_migration_factors_expr_t</a> = decltype(<a class="el" href="namespacemio.html#ab74f1d86f5a3421e7a971c22b50fd89c">get_migration_factors</a>(std::declval&lt; const Sim &amp; &gt;(), std::declval&lt; double &gt;(), std::declval&lt; const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp; &gt;()))</td></tr>
<tr class="memdesc:a55bf290db560dfa35968e2b286ff078f"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect a get_migration_factors function for the Model type.  <a href="namespacemio.html#a55bf290db560dfa35968e2b286ff078f">More...</a><br /></td></tr>
<tr class="separator:a55bf290db560dfa35968e2b286ff078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2af1294cf48bb782478c8d183031c0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5f2af1294cf48bb782478c8d183031c0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a5f2af1294cf48bb782478c8d183031c0">has_apply_constraints_member_function</a> = <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespacemio_1_1details.html#a11800c3db22deebc6aa9f9d457c9add2">details::apply_constraints_expr_t</a>, T &gt;</td></tr>
<tr class="memdesc:a5f2af1294cf48bb782478c8d183031c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether a apply_constraints function exists  <a href="namespacemio.html#a5f2af1294cf48bb782478c8d183031c0">More...</a><br /></td></tr>
<tr class="separator:a5f2af1294cf48bb782478c8d183031c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376021d0dfbbf5639180b1fa30a26f54"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a376021d0dfbbf5639180b1fa30a26f54"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a376021d0dfbbf5639180b1fa30a26f54">has_check_constraints_member_function</a> = <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespacemio_1_1details.html#a3718cd19964b2e578e34c903209a731f">details::check_constraints_expr_t</a>, T &gt;</td></tr>
<tr class="memdesc:a376021d0dfbbf5639180b1fa30a26f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether a check_constraints function exists  <a href="namespacemio.html#a376021d0dfbbf5639180b1fa30a26f54">More...</a><br /></td></tr>
<tr class="separator:a376021d0dfbbf5639180b1fa30a26f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e1937fb0741f02d404d42fd061e37c"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T &gt; </td></tr>
<tr class="memitem:a32e1937fb0741f02d404d42fd061e37c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a32e1937fb0741f02d404d42fd061e37c">has_deserialize</a> = <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespacemio.html#a8bc3cbccffee821ee8b3d10fceb36d1e">deserialize_t</a>, IOContext, T &gt;</td></tr>
<tr class="separator:a32e1937fb0741f02d404d42fd061e37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c639c34c4df5647f084fefb48afc6e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af8c639c34c4df5647f084fefb48afc6e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#af8c639c34c4df5647f084fefb48afc6e">has_eq_op</a> = <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespacemio.html#a628e7270083870520c65318b8c5f2efd">eq_op_t</a>, T &gt;</td></tr>
<tr class="separator:af8c639c34c4df5647f084fefb48afc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0781077265001b4d45934e1793982e5"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:aa0781077265001b4d45934e1793982e5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aa0781077265001b4d45934e1793982e5">has_get_default_member_function</a> = <a class="el" href="structmio_1_1details_1_1has__get__default__member__function.html">details::has_get_default_member_function</a>&lt; T, void, Args... &gt;</td></tr>
<tr class="memdesc:aa0781077265001b4d45934e1793982e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether a get_default function exists  <a href="namespacemio.html#aa0781077265001b4d45934e1793982e5">More...</a><br /></td></tr>
<tr class="separator:aa0781077265001b4d45934e1793982e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828f9a1016d1048d5d3e67dcc5ff4e8f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a828f9a1016d1048d5d3e67dcc5ff4e8f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a828f9a1016d1048d5d3e67dcc5ff4e8f">has_ostream_op</a> = <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespacemio.html#a0c09d69095773d82728cea5345a40008">ostream_op_expr_t</a>, T &gt;</td></tr>
<tr class="separator:a828f9a1016d1048d5d3e67dcc5ff4e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b14b6a7d90203c53336d81ff946932"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T &gt; </td></tr>
<tr class="memitem:a45b14b6a7d90203c53336d81ff946932"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a45b14b6a7d90203c53336d81ff946932">has_serialize</a> = <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespacemio.html#af1c9f969c0a8d114d1cfdff970cc99f9">serialize_t</a>, IOContext, T &gt;</td></tr>
<tr class="separator:a45b14b6a7d90203c53336d81ff946932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e3295400f60de85bac8cc951d22cb3"><td class="memTemplParams" colspan="2">template&lt;class... Loggers&gt; </td></tr>
<tr class="memitem:a18e3295400f60de85bac8cc951d22cb3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a18e3295400f60de85bac8cc951d22cb3">HistoryWithMemoryWriter</a> = <a class="el" href="classmio_1_1History.html">History</a>&lt; <a class="el" href="structmio_1_1DataWriterToMemory.html">DataWriterToMemory</a>, Loggers... &gt;</td></tr>
<tr class="separator:a18e3295400f60de85bac8cc951d22cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802f35511c350a60fbd8838a6df5bd61"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a802f35511c350a60fbd8838a6df5bd61"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a802f35511c350a60fbd8838a6df5bd61">InterpolateResultT</a> = std::decay_t&lt; decltype(<a class="el" href="namespacemio.html#a449f66b75f44f30dc4e70963355f9b5e">interpolate_simulation_result</a>(std::declval&lt; T &gt;()))&gt;</td></tr>
<tr class="memdesc:a802f35511c350a60fbd8838a6df5bd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper template, type returned by overload interpolate_simulation_result(T t)  <a href="namespacemio.html#a802f35511c350a60fbd8838a6df5bd61">More...</a><br /></td></tr>
<tr class="separator:a802f35511c350a60fbd8838a6df5bd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae556a666d14183eb2bf3a3efc11551ec"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae556a666d14183eb2bf3a3efc11551ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a> = boost::outcome_v2::unchecked&lt; T, <a class="el" href="classmio_1_1IOStatus.html">IOStatus</a> &gt;</td></tr>
<tr class="memdesc:ae556a666d14183eb2bf3a3efc11551ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-or-error type for operations that return a value but can fail.  <a href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">More...</a><br /></td></tr>
<tr class="separator:ae556a666d14183eb2bf3a3efc11551ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa0f99f4573e98460b38e88d9c107ba"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:affa0f99f4573e98460b38e88d9c107ba"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#affa0f99f4573e98460b38e88d9c107ba">is_compartment_model</a> = std::integral_constant&lt; bool,(<a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespacemio.html#a27dab8db023c553df90eb71275843f41">eval_right_hand_side_expr_t</a>, M &gt;::value &amp;&amp;<a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespacemio.html#a861b27ba4067e505fdd45dec8087c169">get_initial_values_expr_t</a>, M &gt;::value)&gt;</td></tr>
<tr class="memdesc:affa0f99f4573e98460b38e88d9c107ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template meta function to check if a type is a valid compartment model.  <a href="namespacemio.html#affa0f99f4573e98460b38e88d9c107ba">More...</a><br /></td></tr>
<tr class="separator:affa0f99f4573e98460b38e88d9c107ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fadf09764a83cd8c447f71052cd5d3c"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:a6fadf09764a83cd8c447f71052cd5d3c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a6fadf09764a83cd8c447f71052cd5d3c">is_compartment_model_simulation</a> = std::integral_constant&lt; bool,(<a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespacemio.html#af15ba49097f82eae310c5ed3d21a1b4b">advance_expr_t</a>, Sim &gt;::value &amp;&amp;<a class="el" href="namespacemio.html#affa0f99f4573e98460b38e88d9c107ba">is_compartment_model</a>&lt; typename Sim::Model &gt;::value)&gt;</td></tr>
<tr class="memdesc:a6fadf09764a83cd8c447f71052cd5d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template meta function to check if a type is a compartment model simulation.  <a href="namespacemio.html#a6fadf09764a83cd8c447f71052cd5d3c">More...</a><br /></td></tr>
<tr class="separator:a6fadf09764a83cd8c447f71052cd5d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0752d0ad90c7c7789098b08021da4418"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a0752d0ad90c7c7789098b08021da4418"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a0752d0ad90c7c7789098b08021da4418">is_container</a> = <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespacemio_1_1details.html#aa2c4bf335b2dc1bff2495bf91e60e182">details::compare_iterators_t</a>, C &gt;</td></tr>
<tr class="memdesc:a0752d0ad90c7c7789098b08021da4418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is std::true_type if C is a STL compatible container.  <a href="namespacemio.html#a0752d0ad90c7c7789098b08021da4418">More...</a><br /></td></tr>
<tr class="separator:a0752d0ad90c7c7789098b08021da4418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a13de5a1cf9acb4db85042f9bc948ea"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6a13de5a1cf9acb4db85042f9bc948ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a6a13de5a1cf9acb4db85042f9bc948ea">is_iterator</a> = <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespacemio.html#a2f0a87714e50d80a23c07a795e1ac104">is_iterator_expr_t</a>, T &gt;</td></tr>
<tr class="separator:a6a13de5a1cf9acb4db85042f9bc948ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0a87714e50d80a23c07a795e1ac104"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2f0a87714e50d80a23c07a795e1ac104"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a2f0a87714e50d80a23c07a795e1ac104">is_iterator_expr_t</a> = typename std::iterator_traits&lt; T &gt;::iterator_category</td></tr>
<tr class="memdesc:a2f0a87714e50d80a23c07a795e1ac104"><td class="mdescLeft">&#160;</td><td class="mdescRight">meta function to check type T for beeing an iterator  <a href="namespacemio.html#a2f0a87714e50d80a23c07a795e1ac104">More...</a><br /></td></tr>
<tr class="separator:a2f0a87714e50d80a23c07a795e1ac104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c063374af53e3976102aac4e24d676"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a36c063374af53e3976102aac4e24d676"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a36c063374af53e3976102aac4e24d676">is_matrix_expression</a> = std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;</td></tr>
<tr class="memdesc:a36c063374af53e3976102aac4e24d676"><td class="mdescLeft">&#160;</td><td class="mdescRight">template utility.  <a href="namespacemio.html#a36c063374af53e3976102aac4e24d676">More...</a><br /></td></tr>
<tr class="separator:a36c063374af53e3976102aac4e24d676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0df224333a70c37fba34e10571431e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c0df224333a70c37fba34e10571431e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a8c0df224333a70c37fba34e10571431e">is_no_default_init_tag</a> = std::is_same&lt; <a class="el" href="structmio_1_1NoDefaultInit.html">NoDefaultInit</a>, T &gt;</td></tr>
<tr class="separator:a8c0df224333a70c37fba34e10571431e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bd2141b31d1f93df3d2274c999983b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a59bd2141b31d1f93df3d2274c999983b">MigrationCoefficientGroup</a> = <a class="el" href="classmio_1_1DampingMatrixExpressionGroup.html">DampingMatrixExpressionGroup</a>&lt; <a class="el" href="namespacemio.html#abad9dfcf20607d4e66b7ad62ed250972">MigrationCoefficients</a> &gt;</td></tr>
<tr class="memdesc:a59bd2141b31d1f93df3d2274c999983b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sum of time dependent migration coefficients.  <a href="namespacemio.html#a59bd2141b31d1f93df3d2274c999983b">More...</a><br /></td></tr>
<tr class="separator:a59bd2141b31d1f93df3d2274c999983b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9dfcf20607d4e66b7ad62ed250972"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#abad9dfcf20607d4e66b7ad62ed250972">MigrationCoefficients</a> = <a class="el" href="classmio_1_1DampingMatrixExpression.html">DampingMatrixExpression</a>&lt; <a class="el" href="namespacemio.html#a70fa1b55f14e56241f910c68e9ff75bc">VectorDampings</a> &gt;</td></tr>
<tr class="memdesc:abad9dfcf20607d4e66b7ad62ed250972"><td class="mdescLeft">&#160;</td><td class="mdescRight">time dependent migration coefficients.  <a href="namespacemio.html#abad9dfcf20607d4e66b7ad62ed250972">More...</a><br /></td></tr>
<tr class="separator:abad9dfcf20607d4e66b7ad62ed250972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4546611409ee1989557a481c14b351cc"><td class="memTemplParams" colspan="2">template&lt;bool Cond&gt; </td></tr>
<tr class="memitem:a4546611409ee1989557a481c14b351cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a4546611409ee1989557a481c14b351cc">not_copyable_if</a> = std::conditional&lt; Cond, <a class="el" href="structmio_1_1details_1_1NoCopy.html">details::NoCopy</a>, <a class="el" href="structmio_1_1details_1_1Empty.html">details::Empty</a> &gt;</td></tr>
<tr class="memdesc:a4546611409ee1989557a481c14b351cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a type that is not copy constructible or assignable if the specified condition is true.  <a href="namespacemio.html#a4546611409ee1989557a481c14b351cc">More...</a><br /></td></tr>
<tr class="separator:a4546611409ee1989557a481c14b351cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09eb65dfcf1a9314a36702c9481d8945"><td class="memTemplParams" colspan="2">template&lt;bool Cond&gt; </td></tr>
<tr class="memitem:a09eb65dfcf1a9314a36702c9481d8945"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a09eb65dfcf1a9314a36702c9481d8945">not_copyable_if_t</a> = typename <a class="el" href="namespacemio.html#a4546611409ee1989557a481c14b351cc">not_copyable_if</a>&lt; Cond &gt;::type</td></tr>
<tr class="memdesc:a09eb65dfcf1a9314a36702c9481d8945"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to not_copyable_if&lt;Cond&gt;::type.  <a href="namespacemio.html#a09eb65dfcf1a9314a36702c9481d8945">More...</a><br /></td></tr>
<tr class="separator:a09eb65dfcf1a9314a36702c9481d8945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c09d69095773d82728cea5345a40008"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0c09d69095773d82728cea5345a40008"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a0c09d69095773d82728cea5345a40008">ostream_op_expr_t</a> = decltype(std::declval&lt; std::ostream &amp; &gt;()&lt;&lt; std::declval&lt; T &gt;())</td></tr>
<tr class="memdesc:a0c09d69095773d82728cea5345a40008"><td class="mdescLeft">&#160;</td><td class="mdescRight">meta function to check type T for an existing stream output operator "&lt;&lt;"  <a href="namespacemio.html#a0c09d69095773d82728cea5345a40008">More...</a><br /></td></tr>
<tr class="separator:a0c09d69095773d82728cea5345a40008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bad6be33a5ea18476382e11a8f0f035"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a2bad6be33a5ea18476382e11a8f0f035">ParameterDistributionVisitor</a> = <a class="el" href="structmio_1_1Visitor.html">Visitor</a>&lt; class <a class="el" href="classmio_1_1ParameterDistributionNormal.html">ParameterDistributionNormal</a>, class <a class="el" href="classmio_1_1ParameterDistributionUniform.html">ParameterDistributionUniform</a> &gt;</td></tr>
<tr class="memdesc:a2bad6be33a5ea18476382e11a8f0f035"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a visitor class to visit all Parameter Distribution objects.  <a href="namespacemio.html#a2bad6be33a5ea18476382e11a8f0f035">More...</a><br /></td></tr>
<tr class="separator:a2bad6be33a5ea18476382e11a8f0f035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2819b17099ccd2f065a0434b08e0f568"><td class="memTemplParams" colspan="2">template&lt;size_t I, class ParamSet &gt; </td></tr>
<tr class="memitem:a2819b17099ccd2f065a0434b08e0f568"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a2819b17099ccd2f065a0434b08e0f568">ParameterTag</a> = <a class="el" href="structmio_1_1details_1_1ParameterTag.html">details::ParameterTag</a>&lt; I, ParamSet &gt;</td></tr>
<tr class="memdesc:a2819b17099ccd2f065a0434b08e0f568"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the the tag of the I-th parameter in a set  <a href="namespacemio.html#a2819b17099ccd2f065a0434b08e0f568">More...</a><br /></td></tr>
<tr class="separator:a2819b17099ccd2f065a0434b08e0f568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6887a5640de1b7f7cc6fafd0f46d15"><td class="memTemplParams" colspan="2">template&lt;size_t I, class ParamSet &gt; </td></tr>
<tr class="memitem:a4f6887a5640de1b7f7cc6fafd0f46d15"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a4f6887a5640de1b7f7cc6fafd0f46d15">ParameterTagT</a> = typename <a class="el" href="namespacemio.html#a2819b17099ccd2f065a0434b08e0f568">ParameterTag</a>&lt; I, ParamSet &gt;::Type</td></tr>
<tr class="separator:a4f6887a5640de1b7f7cc6fafd0f46d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c9f969c0a8d114d1cfdff970cc99f9"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T &gt; </td></tr>
<tr class="memitem:af1c9f969c0a8d114d1cfdff970cc99f9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#af1c9f969c0a8d114d1cfdff970cc99f9">serialize_t</a> = decltype(std::declval&lt; T &gt;().<a class="el" href="namespacemio.html#a27a24b9e6cb629e04e9613446f07d6ba">serialize</a>(std::declval&lt; IOContext &amp; &gt;()))</td></tr>
<tr class="separator:af1c9f969c0a8d114d1cfdff970cc99f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a037bdec009fea22e8426a48c1341b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a4a037bdec009fea22e8426a48c1341b8">SquareDamping</a> = <a class="el" href="classmio_1_1Damping.html">Damping</a>&lt; <a class="el" href="classmio_1_1SquareMatrixShape.html">SquareMatrixShape</a> &gt;</td></tr>
<tr class="memdesc:a4a037bdec009fea22e8426a48c1341b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">aliases for common damping specializations.  <a href="namespacemio.html#a4a037bdec009fea22e8426a48c1341b8">More...</a><br /></td></tr>
<tr class="separator:a4a037bdec009fea22e8426a48c1341b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cceedcb6dc114cc6992f13e163d7bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a56cceedcb6dc114cc6992f13e163d7bb">SquareDampings</a> = <a class="el" href="classmio_1_1Dampings.html">Dampings</a>&lt; <a class="el" href="namespacemio.html#a4a037bdec009fea22e8426a48c1341b8">SquareDamping</a> &gt;</td></tr>
<tr class="separator:a56cceedcb6dc114cc6992f13e163d7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f858e287c3935240954cf75cf53cfeb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2f858e287c3935240954cf75cf53cfeb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a> = boost::outcome_v2::in_place_type_t&lt; T &gt;</td></tr>
<tr class="memdesc:a2f858e287c3935240954cf75cf53cfeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that is used for overload resolution.  <a href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">More...</a><br /></td></tr>
<tr class="separator:a2f858e287c3935240954cf75cf53cfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9114c7ed6467f9e2babbe5c9a2c03747"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:a9114c7ed6467f9e2babbe5c9a2c03747"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a9114c7ed6467f9e2babbe5c9a2c03747">test_commuters_expr_t</a> = decltype(<a class="el" href="namespacemio.html#adb526164db4b433fe9e65133f20edd3d">test_commuters</a>(std::declval&lt; Sim &amp; &gt;(), std::declval&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp; &gt;(), std::declval&lt; double &gt;()))</td></tr>
<tr class="memdesc:a9114c7ed6467f9e2babbe5c9a2c03747"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect a get_migration_factors function for the Model type.  <a href="namespacemio.html#a9114c7ed6467f9e2babbe5c9a2c03747">More...</a><br /></td></tr>
<tr class="separator:a9114c7ed6467f9e2babbe5c9a2c03747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c047ef17f8a7233b7e2a26e5ac3d55"><td class="memTemplParams" colspan="2">template&lt;class Real &gt; </td></tr>
<tr class="memitem:af8c047ef17f8a7233b7e2a26e5ac3d55"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#af8c047ef17f8a7233b7e2a26e5ac3d55">UniformDistribution</a> = <a class="el" href="classmio_1_1DistributionAdapter.html">DistributionAdapter</a>&lt; std::uniform_real_distribution&lt; Real &gt; &gt;</td></tr>
<tr class="memdesc:af8c047ef17f8a7233b7e2a26e5ac3d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">adapted uniform_real_distribution.  <a href="namespacemio.html#af8c047ef17f8a7233b7e2a26e5ac3d55">More...</a><br /></td></tr>
<tr class="separator:af8c047ef17f8a7233b7e2a26e5ac3d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edf6ec7616fca58178f25f339d25042"><td class="memTemplParams" colspan="2">template&lt;class Int &gt; </td></tr>
<tr class="memitem:a5edf6ec7616fca58178f25f339d25042"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a5edf6ec7616fca58178f25f339d25042">UniformIntDistribution</a> = <a class="el" href="classmio_1_1DistributionAdapter.html">DistributionAdapter</a>&lt; std::uniform_int_distribution&lt; Int &gt; &gt;</td></tr>
<tr class="memdesc:a5edf6ec7616fca58178f25f339d25042"><td class="mdescLeft">&#160;</td><td class="mdescRight">adapted std::uniform_int_distribution.  <a href="namespacemio.html#a5edf6ec7616fca58178f25f339d25042">More...</a><br /></td></tr>
<tr class="separator:a5edf6ec7616fca58178f25f339d25042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852855378d297141c058aa4d561b90e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a852855378d297141c058aa4d561b90e9">VectorDamping</a> = <a class="el" href="classmio_1_1Damping.html">Damping</a>&lt; <a class="el" href="classmio_1_1ColumnVectorShape.html">ColumnVectorShape</a> &gt;</td></tr>
<tr class="separator:a852855378d297141c058aa4d561b90e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fa1b55f14e56241f910c68e9ff75bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a70fa1b55f14e56241f910c68e9ff75bc">VectorDampings</a> = <a class="el" href="classmio_1_1Dampings.html">Dampings</a>&lt; <a class="el" href="namespacemio.html#a852855378d297141c058aa4d561b90e9">VectorDamping</a> &gt;</td></tr>
<tr class="separator:a70fa1b55f14e56241f910c68e9ff75bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7d5d010d42e770f94cd4e35c0bde71"><td class="memTemplParams" colspan="2">template&lt;class Derived &gt; </td></tr>
<tr class="memitem:aea7d5d010d42e770f94cd4e35c0bde71"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aea7d5d010d42e770f94cd4e35c0bde71">VisitableParameterDistribution</a> = <a class="el" href="structmio_1_1Visitable.html">Visitable</a>&lt; Derived, class <a class="el" href="classmio_1_1ParameterDistribution.html">ParameterDistribution</a>, <a class="el" href="namespacemio.html#a2bad6be33a5ea18476382e11a8f0f035">ParameterDistributionVisitor</a>, <a class="el" href="namespacemio.html#ad8b64973f63b24b787e11ddbbb5f8dc3">ConstParameterDistributionVisitor</a> &gt;</td></tr>
<tr class="separator:aea7d5d010d42e770f94cd4e35c0bde71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11f796ce6022b2a47e39adc29c89fcb"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:af11f796ce6022b2a47e39adc29c89fcb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#af11f796ce6022b2a47e39adc29c89fcb">void_t</a> = typename <a class="el" href="structmio_1_1details_1_1make__void.html">details::make_void</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:af11f796ce6022b2a47e39adc29c89fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility for meta programming that produces void for any valid type.  <a href="namespacemio.html#af11f796ce6022b2a47e39adc29c89fcb">More...</a><br /></td></tr>
<tr class="separator:af11f796ce6022b2a47e39adc29c89fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac653dd1d4b96e115aa994b6a627fac2a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#ac653dd1d4b96e115aa994b6a627fac2a">IOFlags</a> { <a class="el" href="namespacemio.html#ac653dd1d4b96e115aa994b6a627fac2aa3d42ed7bd1f2ca56e839ce87b785c3c8">IOF_None</a> = 0
, <a class="el" href="namespacemio.html#ac653dd1d4b96e115aa994b6a627fac2aa404382b13f293f4a6f83c9dcb6be559f">IOF_OmitDistributions</a> = 1 &lt;&lt; 0
, <a class="el" href="namespacemio.html#ac653dd1d4b96e115aa994b6a627fac2aab2c1a59881d6eff77aec6971ff2b1d21">IOF_OmitValues</a> = 1 &lt;&lt; 1
, <a class="el" href="namespacemio.html#ac653dd1d4b96e115aa994b6a627fac2aac1c4426ed4cd40b1dbe5876d11c0be30">IOF_IncludeTypeInfo</a> = 1 &lt;&lt; 2
 }</td></tr>
<tr class="memdesc:ac653dd1d4b96e115aa994b6a627fac2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">flags to determine the behavior of the serialization process.  <a href="namespacemio.html#ac653dd1d4b96e115aa994b6a627fac2a">More...</a><br /></td></tr>
<tr class="separator:ac653dd1d4b96e115aa994b6a627fac2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67881790c6dfd8c058d27e5f1fe24220"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220">LogLevel</a> { <br />
&#160;&#160;<a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220a04a75036e9d520bb983c5ed03b8d0182">trace</a>
, <a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220aad42f6697b035b7580e4fef93be20b4d">debug</a>
, <a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220acaf9b6b99962bf5c2264824231d7a40c">info</a>
, <a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220a1ea4c3ab05ee0c6d4de30740443769cb">warn</a>
, <br />
&#160;&#160;<a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220a56bd7107802ebe56c6918992f0608ec6">err</a>
, <a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220a7e85bcb66fb9a809d5ab4f62a8b8bea8">critical</a>
, <a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220a3262d48df5d75e3452f0f16b313b7808">off</a>
<br />
 }</td></tr>
<tr class="separator:a67881790c6dfd8c058d27e5f1fe24220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2799d348d433018d5b183d75bfbdd699"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699">StatusCode</a> { <br />
&#160;&#160;<a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699ae0aa021e21dddbd6d8cecec71e9cf564">OK</a> = 0
, <a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699abfaef30f1c8011c5cefa38ae470fb7aa">UnknownError</a> = 1
, <a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699a365b2699d38b61ef4b4c8a1066c8468f">OutOfRange</a>
, <a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699a223e81e8afa42c41346a6696560ecc7b">InvalidValue</a>
, <br />
&#160;&#160;<a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699ade9a4832789ef70d5f9bee2a83345e8a">InvalidFileFormat</a>
, <a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699aa645e4cfc8d16be330607ad52aec5f98">KeyNotFound</a>
, <a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699ac85f85f7c13ed006eed130ec183aa810">InvalidType</a>
, <a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699a2767828026039e8ba7b38973cbb701f2">FileNotFound</a>
<br />
 }</td></tr>
<tr class="memdesc:a2799d348d433018d5b183d75bfbdd699"><td class="mdescLeft">&#160;</td><td class="mdescRight">code to indicate the result of an operation.  <a href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699">More...</a><br /></td></tr>
<tr class="separator:a2799d348d433018d5b183d75bfbdd699"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aee4a248956bde1057171ea901504e5e3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aee4a248956bde1057171ea901504e5e3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aee4a248956bde1057171ea901504e5e3">abs_max</a> (T v1, T v2)</td></tr>
<tr class="memdesc:aee4a248956bde1057171ea901504e5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum absolute value of two numbers.  <a href="namespacemio.html#aee4a248956bde1057171ea901504e5e3">More...</a><br /></td></tr>
<tr class="separator:aee4a248956bde1057171ea901504e5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd34c233549e8b0e086c67fd82809d3"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class F , class... T&gt; </td></tr>
<tr class="memitem:a3cd34c233549e8b0e086c67fd82809d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemio_1_1details.html#a98c0eea24e7bbb725e78e8c7c6b22e8a">details::ApplyResultT</a>&lt; F, T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a3cd34c233549e8b0e086c67fd82809d3">apply</a> (IOContext &amp;io, F f, const <a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; T &gt; &amp;... rs)</td></tr>
<tr class="memdesc:a3cd34c233549e8b0e086c67fd82809d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a function with zero or more unpacked IOResults as arguments.  <a href="namespacemio.html#a3cd34c233549e8b0e086c67fd82809d3">More...</a><br /></td></tr>
<tr class="separator:a3cd34c233549e8b0e086c67fd82809d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d87651a07c02cb6bd9c27a6518069e"><td class="memTemplParams" colspan="2">template&lt;class DampingExpression , class DampingSamplings , class F &gt; </td></tr>
<tr class="memitem:a24d87651a07c02cb6bd9c27a6518069e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a24d87651a07c02cb6bd9c27a6518069e">apply_dampings</a> (DampingExpression &amp;damping_expression, const DampingSamplings &amp;dampings, F make_matrix)</td></tr>
<tr class="memdesc:a24d87651a07c02cb6bd9c27a6518069e"><td class="mdescLeft">&#160;</td><td class="mdescRight">add sampled dampings to a damping expression.  <a href="namespacemio.html#a24d87651a07c02cb6bd9c27a6518069e">More...</a><br /></td></tr>
<tr class="separator:a24d87651a07c02cb6bd9c27a6518069e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bce3d20b307a99caf57331c0250537"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:a70bce3d20b307a99caf57331c0250537"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a70bce3d20b307a99caf57331c0250537">apply_migration</a> (double t, double dt, <a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a> &amp;migrationEdge, <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;node_from, <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;node_to)</td></tr>
<tr class="memdesc:a70bce3d20b307a99caf57331c0250537"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge functor for migration simulation.  <a href="namespacemio.html#a70bce3d20b307a99caf57331c0250537">More...</a><br /></td></tr>
<tr class="separator:a70bce3d20b307a99caf57331c0250537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456698e86179ed8ee48f44e3d9d8d85c"><td class="memTemplParams" colspan="2">template&lt;class Sim , class StochasticEdge &gt; </td></tr>
<tr class="memitem:a456698e86179ed8ee48f44e3d9d8d85c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a456698e86179ed8ee48f44e3d9d8d85c">apply_migration</a> (StochasticEdge &amp;migrationEdge, size_t event, <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;node_from, <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;node_to)</td></tr>
<tr class="memdesc:a456698e86179ed8ee48f44e3d9d8d85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge functor for migration simulation.  <a href="namespacemio.html#a456698e86179ed8ee48f44e3d9d8d85c">More...</a><br /></td></tr>
<tr class="separator:a456698e86179ed8ee48f44e3d9d8d85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64767b14d2fc4a7495e8401fb171bcd"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ac64767b14d2fc4a7495e8401fb171bcd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ac64767b14d2fc4a7495e8401fb171bcd">begin</a> (const M &amp;m)</td></tr>
<tr class="memdesc:ac64767b14d2fc4a7495e8401fb171bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a const iterator to first element of the matrix m.  <a href="namespacemio.html#ac64767b14d2fc4a7495e8401fb171bcd">More...</a><br /></td></tr>
<tr class="separator:ac64767b14d2fc4a7495e8401fb171bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c974748a742fac0093de2634750791"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:aa6c974748a742fac0093de2634750791"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacemio.html#a5e1169fe9e5d36e1c3a2bf558a874049">conjunction_v</a>&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;, <a class="el" href="namespacemio_1_1details.html#aa2d4aa6db3f379aa09e21f3378bd85d2">details::IsElementReference</a>&lt; M &gt; &gt;, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, false &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aa6c974748a742fac0093de2634750791">begin</a> (M &amp;m)</td></tr>
<tr class="memdesc:aa6c974748a742fac0093de2634750791"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a non-const iterator to first element of the matrix m.  <a href="namespacemio.html#aa6c974748a742fac0093de2634750791">More...</a><br /></td></tr>
<tr class="separator:aa6c974748a742fac0093de2634750791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac756601e49cde978ae849e736f7ffd5e"><td class="memTemplParams" colspan="2">template&lt;class Sim , class  = std::enable_if_t&lt;is_compartment_model_simulation&lt;Sim&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ac756601e49cde978ae849e736f7ffd5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ac756601e49cde978ae849e736f7ffd5e">calculate_migration_returns</a> (Eigen::Ref&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;::Vector &gt; migrated, const Sim &amp;sim, Eigen::Ref&lt; const <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;::Vector &gt; total, double t, double dt)</td></tr>
<tr class="memdesc:ac756601e49cde978ae849e736f7ffd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust number of migrated people when they return according to the model.  <a href="namespacemio.html#ac756601e49cde978ae849e736f7ffd5e">More...</a><br /></td></tr>
<tr class="separator:ac756601e49cde978ae849e736f7ffd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a682d1d1100a18177c401a32cbcdb80"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a1a682d1d1100a18177c401a32cbcdb80"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a1a682d1d1100a18177c401a32cbcdb80">cbegin</a> (const M &amp;m)</td></tr>
<tr class="memdesc:a1a682d1d1100a18177c401a32cbcdb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a const iterator to first element of the matrix m.  <a href="namespacemio.html#a1a682d1d1100a18177c401a32cbcdb80">More...</a><br /></td></tr>
<tr class="separator:a1a682d1d1100a18177c401a32cbcdb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b97a27d22568b3ab044955ac3e6f3d"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a28b97a27d22568b3ab044955ac3e6f3d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a28b97a27d22568b3ab044955ac3e6f3d">cend</a> (const M &amp;m)</td></tr>
<tr class="memdesc:a28b97a27d22568b3ab044955ac3e6f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a non-const end iterator for the matrix m.  <a href="namespacemio.html#a28b97a27d22568b3ab044955ac3e6f3d">More...</a><br /></td></tr>
<tr class="separator:a28b97a27d22568b3ab044955ac3e6f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd44eabeb55837aa5f3e2ecfa351f049"><td class="memTemplParams" colspan="2">template&lt;class Iter , class Pred &gt; </td></tr>
<tr class="memitem:afd44eabeb55837aa5f3e2ecfa351f049"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#afd44eabeb55837aa5f3e2ecfa351f049">contains</a> (Iter b, Iter e, Pred p)</td></tr>
<tr class="memdesc:afd44eabeb55837aa5f3e2ecfa351f049"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if there is an element in this range that matches a predicate  <a href="namespacemio.html#afd44eabeb55837aa5f3e2ecfa351f049">More...</a><br /></td></tr>
<tr class="separator:afd44eabeb55837aa5f3e2ecfa351f049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f25a359f1daa4e482fb58724bd9237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a31f25a359f1daa4e482fb58724bd9237">count_lines</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a31f25a359f1daa4e482fb58724bd9237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts lines of txt file.  <a href="namespacemio.html#a31f25a359f1daa4e482fb58724bd9237">More...</a><br /></td></tr>
<tr class="separator:a31f25a359f1daa4e482fb58724bd9237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3e99d87ecd03e78eef03c54a8e58d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a8d3e99d87ecd03e78eef03c54a8e58d2">create_directory</a> (std::string const  &amp;rel_path)</td></tr>
<tr class="memdesc:a8d3e99d87ecd03e78eef03c54a8e58d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory in the file system.  <a href="namespacemio.html#a8d3e99d87ecd03e78eef03c54a8e58d2">More...</a><br /></td></tr>
<tr class="separator:a8d3e99d87ecd03e78eef03c54a8e58d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075272e6cfaf25ad2292e4108c2309a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a075272e6cfaf25ad2292e4108c2309a9">create_directory</a> (std::string const  &amp;rel_path, std::string &amp;abs_path)</td></tr>
<tr class="memdesc:a075272e6cfaf25ad2292e4108c2309a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory in the file system.  <a href="namespacemio.html#a075272e6cfaf25ad2292e4108c2309a9">More...</a><br /></td></tr>
<tr class="separator:a075272e6cfaf25ad2292e4108c2309a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf154a6f66ef76f9a3fbb7424df9c31d"><td class="memTemplParams" colspan="2">template&lt;class NodePropertyT , class EdgePropertyT &gt; </td></tr>
<tr class="memitem:adf154a6f66ef76f9a3fbb7424df9c31d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#adf154a6f66ef76f9a3fbb7424df9c31d">create_graph_without_edges</a> (const std::vector&lt; NodePropertyT &gt; &amp;node_properties, const std::vector&lt; int &gt; &amp;node_ids)</td></tr>
<tr class="memdesc:adf154a6f66ef76f9a3fbb7424df9c31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an unconnected graph.  <a href="namespacemio.html#adf154a6f66ef76f9a3fbb7424df9c31d">More...</a><br /></td></tr>
<tr class="separator:adf154a6f66ef76f9a3fbb7424df9c31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fcaac4322368f99802f6a206a93c92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#ac2fcaac4322368f99802f6a206a93c92">DECL_TYPESAFE</a> (int, DampingLevel)</td></tr>
<tr class="memdesc:ac2fcaac4322368f99802f6a206a93c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer damping level.  <a href="namespacemio.html#ac2fcaac4322368f99802f6a206a93c92">More...</a><br /></td></tr>
<tr class="separator:ac2fcaac4322368f99802f6a206a93c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0876aea98f5bc41a0202c7b0c7fb53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a2b0876aea98f5bc41a0202c7b0c7fb53">DECL_TYPESAFE</a> (int, DampingType)</td></tr>
<tr class="memdesc:a2b0876aea98f5bc41a0202c7b0c7fb53"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer damping type.  <a href="namespacemio.html#a2b0876aea98f5bc41a0202c7b0c7fb53">More...</a><br /></td></tr>
<tr class="separator:a2b0876aea98f5bc41a0202c7b0c7fb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eecf99ef3a231d628f968aeb2136865"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T &gt; </td></tr>
<tr class="memitem:a1eecf99ef3a231d628f968aeb2136865"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a1eecf99ef3a231d628f968aeb2136865">deserialize</a> (IOContext &amp;io, <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; T &gt; tag)</td></tr>
<tr class="memdesc:a1eecf99ef3a231d628f968aeb2136865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores an object from the data stored in an IO context.  <a href="namespacemio.html#a1eecf99ef3a231d628f968aeb2136865">More...</a><br /></td></tr>
<tr class="separator:a1eecf99ef3a231d628f968aeb2136865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4883dd8d61080057dbdccf25181f5462"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4883dd8d61080057dbdccf25181f5462"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a4883dd8d61080057dbdccf25181f5462">deserialize_binary</a> (<a class="el" href="classmio_1_1ByteStream.html">ByteStream</a> &amp;stream, <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; T &gt;, int flags=0)</td></tr>
<tr class="memdesc:a4883dd8d61080057dbdccf25181f5462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an object from binary format.  <a href="namespacemio.html#a4883dd8d61080057dbdccf25181f5462">More...</a><br /></td></tr>
<tr class="separator:a4883dd8d61080057dbdccf25181f5462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1da91fbacc2d6ed8cc4e106d7016e14"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class Container , std::enable_if_t&lt;(is_container&lt; Container &gt;::value &amp;&amp;!is_expression_valid&lt; serialize_t, IOContext, Container &gt;::value), void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ac1da91fbacc2d6ed8cc4e106d7016e14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ac1da91fbacc2d6ed8cc4e106d7016e14">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; Container &gt;)</td></tr>
<tr class="memdesc:ac1da91fbacc2d6ed8cc4e106d7016e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize an STL compatible container.  <a href="namespacemio.html#ac1da91fbacc2d6ed8cc4e106d7016e14">More...</a><br /></td></tr>
<tr class="separator:ac1da91fbacc2d6ed8cc4e106d7016e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1525dc162e36390f91c4e30c4b50d5cc"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class E , std::enable_if_t&lt; std::is_enum&lt; E &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a1525dc162e36390f91c4e30c4b50d5cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a1525dc162e36390f91c4e30c4b50d5cc">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; E &gt;)</td></tr>
<tr class="memdesc:a1525dc162e36390f91c4e30c4b50d5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize an enum value from its underlying type.  <a href="namespacemio.html#a1525dc162e36390f91c4e30c4b50d5cc">More...</a><br /></td></tr>
<tr class="separator:a1525dc162e36390f91c4e30c4b50d5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210ceb31e6e751b667b64fe06389b6a5"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class M , std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a210ceb31e6e751b667b64fe06389b6a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a210ceb31e6e751b667b64fe06389b6a5">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; M &gt;)</td></tr>
<tr class="memdesc:a210ceb31e6e751b667b64fe06389b6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize an Eigen matrix.  <a href="namespacemio.html#a210ceb31e6e751b667b64fe06389b6a5">More...</a><br /></td></tr>
<tr class="separator:a210ceb31e6e751b667b64fe06389b6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed78855a4ca0601a2661465658052c49"><td class="memTemplParams" colspan="2">template&lt;class IOContext &gt; </td></tr>
<tr class="memitem:aed78855a4ca0601a2661465658052c49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; std::shared_ptr&lt; <a class="el" href="classmio_1_1ParameterDistribution.html">ParameterDistribution</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aed78855a4ca0601a2661465658052c49">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; std::shared_ptr&lt; <a class="el" href="classmio_1_1ParameterDistribution.html">ParameterDistribution</a> &gt;&gt;)</td></tr>
<tr class="memdesc:aed78855a4ca0601a2661465658052c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize a parameter distribution as a shared_ptr.  <a href="namespacemio.html#aed78855a4ca0601a2661465658052c49">More...</a><br /></td></tr>
<tr class="separator:aed78855a4ca0601a2661465658052c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bee6e76e87298ab8dc95c7c97591f6f"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T , std::enable_if_t&lt; has_deserialize&lt; IOContext, T &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a3bee6e76e87298ab8dc95c7c97591f6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a3bee6e76e87298ab8dc95c7c97591f6f">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; T &gt;)</td></tr>
<tr class="memdesc:a3bee6e76e87298ab8dc95c7c97591f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize an object that has a deserialize(io) static member function.  <a href="namespacemio.html#a3bee6e76e87298ab8dc95c7c97591f6f">More...</a><br /></td></tr>
<tr class="separator:a3bee6e76e87298ab8dc95c7c97591f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cf52f73f21f24b421264732496fe81"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class Tup , class  = std::enable_if_t&lt;is_expression_valid&lt;details::tuple_size_value_t, Tup&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a00cf52f73f21f24b421264732496fe81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; Tup &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a00cf52f73f21f24b421264732496fe81">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; Tup &gt; tag)</td></tr>
<tr class="memdesc:a00cf52f73f21f24b421264732496fe81"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize a tuple-like object, e.g.  <a href="namespacemio.html#a00cf52f73f21f24b421264732496fe81">More...</a><br /></td></tr>
<tr class="separator:a00cf52f73f21f24b421264732496fe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53006511360e7600ccee2ca9732a3d72"><td class="memTemplParams" colspan="2">template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:a53006511360e7600ccee2ca9732a3d72"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a53006511360e7600ccee2ca9732a3d72">dynamic_unique_ptr_cast</a> (std::unique_ptr&lt; T &gt; &amp;&amp;base_ptr)</td></tr>
<tr class="memdesc:a53006511360e7600ccee2ca9732a3d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a unique_ptr&lt;T&gt; to unique_ptr<u>. </u> <a href="namespacemio.html#a53006511360e7600ccee2ca9732a3d72">More...</a><br /></td></tr>
<tr class="separator:a53006511360e7600ccee2ca9732a3d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05d756edaa40a44169157a01a25162b"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ad05d756edaa40a44169157a01a25162b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ad05d756edaa40a44169157a01a25162b">end</a> (const M &amp;m)</td></tr>
<tr class="memdesc:ad05d756edaa40a44169157a01a25162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a const end iterator for the matrix m.  <a href="namespacemio.html#ad05d756edaa40a44169157a01a25162b">More...</a><br /></td></tr>
<tr class="separator:ad05d756edaa40a44169157a01a25162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e603f62801572c7afdf910bc057681"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a81e603f62801572c7afdf910bc057681"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacemio.html#a5e1169fe9e5d36e1c3a2bf558a874049">conjunction_v</a>&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;, <a class="el" href="namespacemio_1_1details.html#aa2d4aa6db3f379aa09e21f3378bd85d2">details::IsElementReference</a>&lt; M &gt; &gt;, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, false &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a81e603f62801572c7afdf910bc057681">end</a> (M &amp;m)</td></tr>
<tr class="memdesc:a81e603f62801572c7afdf910bc057681"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a non-const end iterator for the matrix m.  <a href="namespacemio.html#a81e603f62801572c7afdf910bc057681">More...</a><br /></td></tr>
<tr class="separator:a81e603f62801572c7afdf910bc057681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dd731de720e6138565538e26b0f01b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a88dd731de720e6138565538e26b0f01b">ensemble_mean</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;ensemble_results)</td></tr>
<tr class="memdesc:a88dd731de720e6138565538e26b0f01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes mean of each compartment, node, and time point over all runs input must be uniform as returned by interpolated_ensemble_result: same number of nodes, same time points and elements.  <a href="namespacemio.html#a88dd731de720e6138565538e26b0f01b">More...</a><br /></td></tr>
<tr class="separator:a88dd731de720e6138565538e26b0f01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e6c3ccb05b51b0a86cec52f57d49a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a66e6c3ccb05b51b0a86cec52f57d49a1">ensemble_percentile</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;ensemble_result, double p)</td></tr>
<tr class="memdesc:a66e6c3ccb05b51b0a86cec52f57d49a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the p percentile of the result for each compartment, node, and time point.  <a href="namespacemio.html#a66e6c3ccb05b51b0a86cec52f57d49a1">More...</a><br /></td></tr>
<tr class="separator:a66e6c3ccb05b51b0a86cec52f57d49a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf8e2a8ccea82f3bbd91c3d479d1094"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:aebf8e2a8ccea82f3bbd91c3d479d1094"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aebf8e2a8ccea82f3bbd91c3d479d1094">evolve_model</a> (double t, double dt, <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;node)</td></tr>
<tr class="memdesc:aebf8e2a8ccea82f3bbd91c3d479d1094"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge functor for migration simulation.  <a href="namespacemio.html#aebf8e2a8ccea82f3bbd91c3d479d1094">More...</a><br /></td></tr>
<tr class="separator:aebf8e2a8ccea82f3bbd91c3d479d1094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23604adfeac7ebc8418d741959e80906"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a23604adfeac7ebc8418d741959e80906">failure</a> (const <a class="el" href="classmio_1_1IOStatus.html">IOStatus</a> &amp;s)</td></tr>
<tr class="memdesc:a23604adfeac7ebc8418d741959e80906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object that is implicitly convertible to an error IOResult&lt;T&gt;.  <a href="namespacemio.html#a23604adfeac7ebc8418d741959e80906">More...</a><br /></td></tr>
<tr class="separator:a23604adfeac7ebc8418d741959e80906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bf8987d98c937bf01f7ba27b5a2b1a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#ad0bf8987d98c937bf01f7ba27b5a2b1a">failure</a> (std::error_code c, const std::string &amp;msg=&quot;&quot;)</td></tr>
<tr class="memdesc:ad0bf8987d98c937bf01f7ba27b5a2b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object that is implicitly convertible to an error IOResult&lt;T&gt;.  <a href="namespacemio.html#ad0bf8987d98c937bf01f7ba27b5a2b1a">More...</a><br /></td></tr>
<tr class="separator:ad0bf8987d98c937bf01f7ba27b5a2b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59f4cb5fc6b5dd160a8e1a9b049da85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#aa59f4cb5fc6b5dd160a8e1a9b049da85">file_exists</a> (std::string const  &amp;rel_path, std::string &amp;abs_path)</td></tr>
<tr class="memdesc:aa59f4cb5fc6b5dd160a8e1a9b049da85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a file exists.  <a href="namespacemio.html#aa59f4cb5fc6b5dd160a8e1a9b049da85">More...</a><br /></td></tr>
<tr class="separator:aa59f4cb5fc6b5dd160a8e1a9b049da85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38394b93b07245eb4a96b20810547004"><td class="memTemplParams" colspan="2">template&lt;class TS , class FP &gt; </td></tr>
<tr class="memitem:a38394b93b07245eb4a96b20810547004"><td class="memTemplItemLeft" align="right" valign="top">decltype(std::declval&lt; TS &gt;().rend())&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a38394b93b07245eb4a96b20810547004">find_value_reverse</a> (TS &amp;&amp;ts, FP t_search, FP abs_tol=0, FP rel_tol=0)</td></tr>
<tr class="memdesc:a38394b93b07245eb4a96b20810547004"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the value in the time series at time t_search starting from the end.  <a href="namespacemio.html#a38394b93b07245eb4a96b20810547004">More...</a><br /></td></tr>
<tr class="separator:a38394b93b07245eb4a96b20810547004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c86fcbad351d59edddf6f8a113f338"><td class="memTemplParams" colspan="2">template&lt;typename MultiIndex &gt; </td></tr>
<tr class="memitem:aa3c86fcbad351d59edddf6f8a113f338"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aa3c86fcbad351d59edddf6f8a113f338">flatten_index</a> (MultiIndex const &amp;indices, MultiIndex const &amp;dimensions)</td></tr>
<tr class="memdesc:aa3c86fcbad351d59edddf6f8a113f338"><td class="mdescLeft">&#160;</td><td class="mdescRight">flatten_index takes a set of indices into a mutlidemsional array and calculates the flat index  <a href="namespacemio.html#aa3c86fcbad351d59edddf6f8a113f338">More...</a><br /></td></tr>
<tr class="separator:aa3c86fcbad351d59edddf6f8a113f338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a2754ccbfffaac53e9769bd3cc6012"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa0a2754ccbfffaac53e9769bd3cc6012"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aa0a2754ccbfffaac53e9769bd3cc6012">floating_point_equal</a> (T v1, T v2, T abs_tol=0, T rel_tol=std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:aa0a2754ccbfffaac53e9769bd3cc6012"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two floating point values for equality with tolerances.  <a href="namespacemio.html#aa0a2754ccbfffaac53e9769bd3cc6012">More...</a><br /></td></tr>
<tr class="separator:aa0a2754ccbfffaac53e9769bd3cc6012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39bcb0450014505388317998eac4382"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae39bcb0450014505388317998eac4382"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ae39bcb0450014505388317998eac4382">floating_point_greater</a> (T v1, T v2, T abs_tol=0, T rel_tol=std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:ae39bcb0450014505388317998eac4382"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two floating point values with tolerances.  <a href="namespacemio.html#ae39bcb0450014505388317998eac4382">More...</a><br /></td></tr>
<tr class="separator:ae39bcb0450014505388317998eac4382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25921aa2ea732bff75b46b5b6732fd0e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a25921aa2ea732bff75b46b5b6732fd0e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a25921aa2ea732bff75b46b5b6732fd0e">floating_point_greater_equal</a> (T v1, T v2, T abs_tol=0, T rel_tol=std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:a25921aa2ea732bff75b46b5b6732fd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two floating point values with tolerances.  <a href="namespacemio.html#a25921aa2ea732bff75b46b5b6732fd0e">More...</a><br /></td></tr>
<tr class="separator:a25921aa2ea732bff75b46b5b6732fd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9bad77bdfbdd77c10acb268da42188"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f9bad77bdfbdd77c10acb268da42188"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a1f9bad77bdfbdd77c10acb268da42188">floating_point_less</a> (T v1, T v2, T abs_tol=0, T rel_tol=std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:a1f9bad77bdfbdd77c10acb268da42188"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two floating point values with tolerances.  <a href="namespacemio.html#a1f9bad77bdfbdd77c10acb268da42188">More...</a><br /></td></tr>
<tr class="separator:a1f9bad77bdfbdd77c10acb268da42188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e09296ef9bcb3133b719e0356b1092"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a77e09296ef9bcb3133b719e0356b1092"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a77e09296ef9bcb3133b719e0356b1092">floating_point_less_equal</a> (T v1, T v2, T abs_tol=0, T rel_tol=std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:a77e09296ef9bcb3133b719e0356b1092"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two floating point values with tolerances.  <a href="namespacemio.html#a77e09296ef9bcb3133b719e0356b1092">More...</a><br /></td></tr>
<tr class="separator:a77e09296ef9bcb3133b719e0356b1092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4636578fa72f7895297605fe68d1a8"><td class="memTemplParams" colspan="2">template&lt;class F , class... Tags&gt; </td></tr>
<tr class="memitem:a8b4636578fa72f7895297605fe68d1a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a8b4636578fa72f7895297605fe68d1a8">foreach</a> (const <a class="el" href="classmio_1_1ParameterSet.html">ParameterSet</a>&lt; Tags... &gt; &amp;p, F f)</td></tr>
<tr class="memdesc:a8b4636578fa72f7895297605fe68d1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">call f(p, t) for all parameters in a <a class="el" href="classmio_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> with p the value of the parameter t a default constructed parameter tag  <a href="namespacemio.html#a8b4636578fa72f7895297605fe68d1a8">More...</a><br /></td></tr>
<tr class="separator:a8b4636578fa72f7895297605fe68d1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2e332916b581a92ab49fa06b25606a"><td class="memTemplParams" colspan="2">template&lt;class F , class... Tags&gt; </td></tr>
<tr class="memitem:a1e2e332916b581a92ab49fa06b25606a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a1e2e332916b581a92ab49fa06b25606a">foreach</a> (<a class="el" href="classmio_1_1ParameterSet.html">ParameterSet</a>&lt; Tags... &gt; &amp;p, F f)</td></tr>
<tr class="separator:a1e2e332916b581a92ab49fa06b25606a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bb377d592d615e42466404fabe9c88"><td class="memTemplParams" colspan="2">template&lt;class Params , class F &gt; </td></tr>
<tr class="memitem:a39bb377d592d615e42466404fabe9c88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a39bb377d592d615e42466404fabe9c88">foreach_tag</a> (F f)</td></tr>
<tr class="memdesc:a39bb377d592d615e42466404fabe9c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">call f(t) for all parameters in a <a class="el" href="classmio_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> with t a default constructed parameter tag  <a href="namespacemio.html#a39bb377d592d615e42466404fabe9c88">More...</a><br /></td></tr>
<tr class="separator:a39bb377d592d615e42466404fabe9c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfe99028c36206c267431a3549f3c6e"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6bfe99028c36206c267431a3549f3c6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::tuple_element&lt; I, std::tuple&lt; <a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags &gt;... &gt; &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a6bfe99028c36206c267431a3549f3c6e">get</a> (<a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags... &gt; &amp;i) noexcept</td></tr>
<tr class="separator:a6bfe99028c36206c267431a3549f3c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5628c5c563026082e6d80065e86192ba"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5628c5c563026082e6d80065e86192ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classmio_1_1Index.html">Index</a>&lt; <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a5628c5c563026082e6d80065e86192ba">get</a> (<a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags... &gt; &amp;i) noexcept</td></tr>
<tr class="separator:a5628c5c563026082e6d80065e86192ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa927253c961ab06ce52b147bc8449115"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa927253c961ab06ce52b147bc8449115"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::tuple_element&lt; I, std::tuple&lt; <a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags &gt;... &gt; &gt;::type const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aa927253c961ab06ce52b147bc8449115">get</a> (<a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags... &gt; const &amp;i) noexcept</td></tr>
<tr class="separator:aa927253c961ab06ce52b147bc8449115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78eb98cdade4f5eb661d0acd2f51620"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af78eb98cdade4f5eb661d0acd2f51620"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classmio_1_1Index.html">Index</a>&lt; <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a> &gt; const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#af78eb98cdade4f5eb661d0acd2f51620">get</a> (<a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags... &gt; const &amp;i) noexcept</td></tr>
<tr class="separator:af78eb98cdade4f5eb661d0acd2f51620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d5ab01f91eb6076294d22fec9387e2"><td class="memTemplParams" colspan="2">template&lt;class DampingExpr &gt; </td></tr>
<tr class="memitem:a11d5ab01f91eb6076294d22fec9387e2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Ref&lt; const typename DampingExpr::Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a11d5ab01f91eb6076294d22fec9387e2">get_active_damping</a> (const DampingExpr &amp;damping_expr, DampingLevel lvl, DampingType type, <a class="el" href="classmio_1_1SimulationTime.html">SimulationTime</a> t)</td></tr>
<tr class="memdesc:a11d5ab01f91eb6076294d22fec9387e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the damping that matches the given type and level and that is active at the specified time.  <a href="namespacemio.html#a11d5ab01f91eb6076294d22fec9387e2">More...</a><br /></td></tr>
<tr class="separator:a11d5ab01f91eb6076294d22fec9387e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d08a85d7a7fb01a5ff6899c6003164"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a25d08a85d7a7fb01a5ff6899c6003164">get_current_dir_name</a> ()</td></tr>
<tr class="memdesc:a25d08a85d7a7fb01a5ff6899c6003164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current working directory name.  <a href="namespacemio.html#a25d08a85d7a7fb01a5ff6899c6003164">More...</a><br /></td></tr>
<tr class="separator:a25d08a85d7a7fb01a5ff6899c6003164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e96aa6399be967e2261e9054d45fa3"><td class="memTemplParams" colspan="2">template&lt;class DampingExpr &gt; </td></tr>
<tr class="memitem:a46e96aa6399be967e2261e9054d45fa3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a46e96aa6399be967e2261e9054d45fa3">get_damping_indices</a> (const DampingExpr &amp;damping_expr, DampingLevel lvl, DampingType type, <a class="el" href="classmio_1_1SimulationTime.html">SimulationTime</a> <a class="el" href="namespacemio.html#aa6c974748a742fac0093de2634750791">begin</a>, <a class="el" href="classmio_1_1SimulationTime.html">SimulationTime</a> <a class="el" href="namespacemio.html#a81e603f62801572c7afdf910bc057681">end</a>)</td></tr>
<tr class="memdesc:a46e96aa6399be967e2261e9054d45fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of indices of specified dampings.  <a href="namespacemio.html#a46e96aa6399be967e2261e9054d45fa3">More...</a><br /></td></tr>
<tr class="separator:a46e96aa6399be967e2261e9054d45fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05c44a9a8cdb809f88f9b7f0767ba48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#af05c44a9a8cdb809f88f9b7f0767ba48">get_day_in_year</a> (<a class="el" href="structmio_1_1Date.html">Date</a> date)</td></tr>
<tr class="memdesc:af05c44a9a8cdb809f88f9b7f0767ba48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the day in year based on a given date.  <a href="namespacemio.html#af05c44a9a8cdb809f88f9b7f0767ba48">More...</a><br /></td></tr>
<tr class="separator:af05c44a9a8cdb809f88f9b7f0767ba48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ab6b99636fa04a3d21cb8d08fc4c08"><td class="memTemplParams" colspan="2">template&lt;class Sim , std::enable_if_t&lt;!is_expression_valid&lt; get_infections_relative_expr_t, Sim &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a85ab6b99636fa04a3d21cb8d08fc4c08"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a85ab6b99636fa04a3d21cb8d08fc4c08">get_infections_relative</a> (const <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;, double, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;)</td></tr>
<tr class="memdesc:a85ab6b99636fa04a3d21cb8d08fc4c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the percantage of infected people of the total population in the node If dynamic NPIs are enabled, there needs to be an overload of get_infections_relative(model, y) for the Model type that can be found with argument-dependent lookup.  <a href="namespacemio.html#a85ab6b99636fa04a3d21cb8d08fc4c08">More...</a><br /></td></tr>
<tr class="separator:a85ab6b99636fa04a3d21cb8d08fc4c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74f1d86f5a3421e7a971c22b50fd89c"><td class="memTemplParams" colspan="2">template&lt;class Sim , std::enable_if_t&lt;!is_expression_valid&lt; get_migration_factors_expr_t, Sim &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ab74f1d86f5a3421e7a971c22b50fd89c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ab74f1d86f5a3421e7a971c22b50fd89c">get_migration_factors</a> (const <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;, double, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;y)</td></tr>
<tr class="memdesc:ab74f1d86f5a3421e7a971c22b50fd89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an additional migration factor.  <a href="namespacemio.html#ab74f1d86f5a3421e7a971c22b50fd89c">More...</a><br /></td></tr>
<tr class="separator:ab74f1d86f5a3421e7a971c22b50fd89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836ec51b48f63ad6dca0724e9f5b28d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a836ec51b48f63ad6dca0724e9f5b28d8">get_offset_in_days</a> (<a class="el" href="structmio_1_1Date.html">Date</a> date1, <a class="el" href="structmio_1_1Date.html">Date</a> date2)</td></tr>
<tr class="memdesc:a836ec51b48f63ad6dca0724e9f5b28d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the offset in days given two dates: first date minus second date.  <a href="namespacemio.html#a836ec51b48f63ad6dca0724e9f5b28d8">More...</a><br /></td></tr>
<tr class="separator:a836ec51b48f63ad6dca0724e9f5b28d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14a93cf79d658750a62533c6c31d47c"><td class="memTemplParams" colspan="2">template&lt;class DampingExprGroup , class MakeMatrix &gt; </td></tr>
<tr class="memitem:ab14a93cf79d658750a62533c6c31d47c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ab14a93cf79d658750a62533c6c31d47c">implement_dynamic_npis</a> (DampingExprGroup &amp;damping_expr_group, const std::vector&lt; <a class="el" href="classmio_1_1DampingSampling.html">DampingSampling</a> &gt; &amp;npis, <a class="el" href="classmio_1_1SimulationTime.html">SimulationTime</a> <a class="el" href="namespacemio.html#aa6c974748a742fac0093de2634750791">begin</a>, <a class="el" href="classmio_1_1SimulationTime.html">SimulationTime</a> <a class="el" href="namespacemio.html#a81e603f62801572c7afdf910bc057681">end</a>, MakeMatrix &amp;&amp;make_matrix)</td></tr>
<tr class="memdesc:ab14a93cf79d658750a62533c6c31d47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">implement dynamic NPIs for a time span.  <a href="namespacemio.html#ab14a93cf79d658750a62533c6c31d47c">More...</a><br /></td></tr>
<tr class="separator:ab14a93cf79d658750a62533c6c31d47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe01e2795a0e0b69936834f050129964"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe01e2795a0e0b69936834f050129964"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#abe01e2795a0e0b69936834f050129964">insert_sorted_replace</a> (std::vector&lt; T &gt; &amp;vec, T const &amp;item)</td></tr>
<tr class="separator:abe01e2795a0e0b69936834f050129964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af182124b02db89381844675d1365a286"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:af182124b02db89381844675d1365a286"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#af182124b02db89381844675d1365a286">insert_sorted_replace</a> (std::vector&lt; T &gt; &amp;vec, T const &amp;item, Pred pred)</td></tr>
<tr class="memdesc:af182124b02db89381844675d1365a286"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts element in a sorted vector, replacing items that are equal precondition: elements in the vector are partially sorted and unique according the predicate postcondition: same as precondition, additionally contains exactly one element that is equal to item, order of other items is preserved  <a href="namespacemio.html#af182124b02db89381844675d1365a286">More...</a><br /></td></tr>
<tr class="separator:af182124b02db89381844675d1365a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19cc9b7e5eb64f5ce5464de5511f737"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae19cc9b7e5eb64f5ce5464de5511f737"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemio.html#a802f35511c350a60fbd8838a6df5bd61">InterpolateResultT</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ae19cc9b7e5eb64f5ce5464de5511f737">interpolate_ensemble_results</a> (const std::vector&lt; T &gt; &amp;ensemble_results)</td></tr>
<tr class="memdesc:ae19cc9b7e5eb64f5ce5464de5511f737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates results of all runs with evenly spaced, integer time points that represent whole days.  <a href="namespacemio.html#ae19cc9b7e5eb64f5ce5464de5511f737">More...</a><br /></td></tr>
<tr class="separator:ae19cc9b7e5eb64f5ce5464de5511f737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192b86ffbea1443e5fcdaaacce671227"><td class="memTemplParams" colspan="2">template&lt;class Simulation &gt; </td></tr>
<tr class="memitem:a192b86ffbea1443e5fcdaaacce671227"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a192b86ffbea1443e5fcdaaacce671227">interpolate_simulation_result</a> (const <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; <a class="el" href="classmio_1_1Simulation.html">Simulation</a> &gt;, <a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a> &gt; &amp;graph_result)</td></tr>
<tr class="memdesc:a192b86ffbea1443e5fcdaaacce671227"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpolate time series with evenly spaced, integer time points for each node.  <a href="namespacemio.html#a192b86ffbea1443e5fcdaaacce671227">More...</a><br /></td></tr>
<tr class="separator:a192b86ffbea1443e5fcdaaacce671227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449f66b75f44f30dc4e70963355f9b5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a449f66b75f44f30dc4e70963355f9b5e">interpolate_simulation_result</a> (const <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &amp;simulation_result, const double abs_tol=1e-14)</td></tr>
<tr class="memdesc:a449f66b75f44f30dc4e70963355f9b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpolate time series with evenly spaced, integer time points that represent whole days.  <a href="namespacemio.html#a449f66b75f44f30dc4e70963355f9b5e">More...</a><br /></td></tr>
<tr class="separator:a449f66b75f44f30dc4e70963355f9b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcfb78101db4f3634bad069f1e2271f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a7dcfb78101db4f3634bad069f1e2271f">interpolate_simulation_result</a> (const <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &amp;simulation_result, const std::vector&lt; double &gt; &amp;interpolation_times)</td></tr>
<tr class="memdesc:a7dcfb78101db4f3634bad069f1e2271f"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpolate time series with freely chosen time points that lie in between the time points of the given time series up to a given tolerance.  <a href="namespacemio.html#a7dcfb78101db4f3634bad069f1e2271f">More...</a><br /></td></tr>
<tr class="separator:a7dcfb78101db4f3634bad069f1e2271f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a8c32ccd44e57584abc88bf22eee11"><td class="memTemplParams" colspan="2">template&lt;typename X , typename V &gt; </td></tr>
<tr class="memitem:a46a8c32ccd44e57584abc88bf22eee11"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a46a8c32ccd44e57584abc88bf22eee11">linear_interpolation</a> (const X &amp;x_eval, const X &amp;x_1, const X &amp;x_2, const V &amp;y1, const V &amp;y2)</td></tr>
<tr class="memdesc:a46a8c32ccd44e57584abc88bf22eee11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation between two data values.  <a href="namespacemio.html#a46a8c32ccd44e57584abc88bf22eee11">More...</a><br /></td></tr>
<tr class="separator:a46a8c32ccd44e57584abc88bf22eee11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8e658f565465ae076eab415d976e1b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7a8e658f565465ae076eab415d976e1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a7a8e658f565465ae076eab415d976e1b">log</a> (<a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220">LogLevel</a> level, spdlog::string_view_t fmt, const Args &amp;... args)</td></tr>
<tr class="separator:a7a8e658f565465ae076eab415d976e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9760c798e6f1ea1678ca898d35f201a6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9760c798e6f1ea1678ca898d35f201a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a9760c798e6f1ea1678ca898d35f201a6">log_debug</a> (spdlog::string_view_t fmt, const Args &amp;... args)</td></tr>
<tr class="separator:a9760c798e6f1ea1678ca898d35f201a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89afc3ebfa2c5ab994ec3c76dcad85d1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a89afc3ebfa2c5ab994ec3c76dcad85d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a89afc3ebfa2c5ab994ec3c76dcad85d1">log_error</a> (spdlog::string_view_t fmt, const Args &amp;... args)</td></tr>
<tr class="separator:a89afc3ebfa2c5ab994ec3c76dcad85d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6967891e4710c8a2305b434043c0b2"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aef6967891e4710c8a2305b434043c0b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aef6967891e4710c8a2305b434043c0b2">log_info</a> (spdlog::string_view_t fmt, const Args &amp;... args)</td></tr>
<tr class="separator:aef6967891e4710c8a2305b434043c0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa08ba47cc4a92310059cd08339a1b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#aaaa08ba47cc4a92310059cd08339a1b9">log_rng_seeds</a> (const <a class="el" href="classmio_1_1RandomNumberGenerator.html">RandomNumberGenerator</a> &amp;rng, <a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220">LogLevel</a> level)</td></tr>
<tr class="separator:aaaa08ba47cc4a92310059cd08339a1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff57ca749faaa72cd181e50bdd8d3da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a6ff57ca749faaa72cd181e50bdd8d3da">log_thread_local_rng_seeds</a> (<a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220">LogLevel</a> level)</td></tr>
<tr class="separator:a6ff57ca749faaa72cd181e50bdd8d3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f961d5004bf46cf1cee1133671f8bc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a34f961d5004bf46cf1cee1133671f8bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a34f961d5004bf46cf1cee1133671f8bc">log_warning</a> (spdlog::string_view_t fmt, const Args &amp;... args)</td></tr>
<tr class="separator:a34f961d5004bf46cf1cee1133671f8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c57c15f2d7d146f3eba791912465106"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a4c57c15f2d7d146f3eba791912465106"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a4c57c15f2d7d146f3eba791912465106">major_size</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:a4c57c15f2d7d146f3eba791912465106"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of rows (columns) of a row (column) major matrix.  <a href="namespacemio.html#a4c57c15f2d7d146f3eba791912465106">More...</a><br /></td></tr>
<tr class="separator:a4c57c15f2d7d146f3eba791912465106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9f267ac11fbfcb48a6642dbbd60dba"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a4c9f267ac11fbfcb48a6642dbbd60dba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a4c9f267ac11fbfcb48a6642dbbd60dba">make_contact_damping_matrix</a> (V &amp;&amp;groups)</td></tr>
<tr class="memdesc:a4c9f267ac11fbfcb48a6642dbbd60dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a contact damping matrix from dampings by group.  <a href="namespacemio.html#a4c9f267ac11fbfcb48a6642dbbd60dba">More...</a><br /></td></tr>
<tr class="separator:a4c9f267ac11fbfcb48a6642dbbd60dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5befe24df9218b2206b79a49e9aba87"><td class="memItemLeft" align="right" valign="top">const std::error_code &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#ad5befe24df9218b2206b79a49e9aba87">make_error_code</a> (const <a class="el" href="classmio_1_1IOStatus.html">IOStatus</a> &amp;status)</td></tr>
<tr class="memdesc:ad5befe24df9218b2206b79a49e9aba87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <a class="el" href="classmio_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> to std::error_code.  <a href="namespacemio.html#ad5befe24df9218b2206b79a49e9aba87">More...</a><br /></td></tr>
<tr class="separator:ad5befe24df9218b2206b79a49e9aba87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531d453fb999299bf5437b66a2996d4b"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a531d453fb999299bf5437b66a2996d4b">make_error_code</a> (<a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699">StatusCode</a> e)</td></tr>
<tr class="memdesc:a531d453fb999299bf5437b66a2996d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert StatusCode to std::error_code.  <a href="namespacemio.html#a531d453fb999299bf5437b66a2996d4b">More...</a><br /></td></tr>
<tr class="separator:a531d453fb999299bf5437b66a2996d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa713d3a77fed175359840122fa6df9ba"><td class="memTemplParams" colspan="2">template&lt;class Graph , class NodeF , class EdgeF &gt; </td></tr>
<tr class="memitem:aa713d3a77fed175359840122fa6df9ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aa713d3a77fed175359840122fa6df9ba">make_graph_sim</a> (double t0, double dt, <a class="el" href="classmio_1_1Graph.html">Graph</a> &amp;&amp;g, NodeF &amp;&amp;node_func, EdgeF &amp;&amp;edge_func)</td></tr>
<tr class="separator:aa713d3a77fed175359840122fa6df9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b6bb635d6376fc1886175c4f8e75d3"><td class="memTemplParams" colspan="2">template&lt;class Graph , class NodeF , class EdgeF &gt; </td></tr>
<tr class="memitem:a82b6bb635d6376fc1886175c4f8e75d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a82b6bb635d6376fc1886175c4f8e75d3">make_graph_sim_stochastic</a> (double t0, double dt, <a class="el" href="classmio_1_1Graph.html">Graph</a> &amp;&amp;g, NodeF &amp;&amp;node_func, EdgeF &amp;&amp;edge_func)</td></tr>
<tr class="separator:a82b6bb635d6376fc1886175c4f8e75d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad829a4e21b9bfa28bac6b3359a0c3cf3"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ad829a4e21b9bfa28bac6b3359a0c3cf3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ad829a4e21b9bfa28bac6b3359a0c3cf3">make_migration_damping_vector</a> (<a class="el" href="classmio_1_1ColumnVectorShape.html">ColumnVectorShape</a> shape, V &amp;&amp;groups)</td></tr>
<tr class="memdesc:ad829a4e21b9bfa28bac6b3359a0c3cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make migration coefficient damping vector from dampings by group.  <a href="namespacemio.html#ad829a4e21b9bfa28bac6b3359a0c3cf3">More...</a><br /></td></tr>
<tr class="separator:ad829a4e21b9bfa28bac6b3359a0c3cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9874bbe82f7ecb6f7f6a00a55f2c2bbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9874bbe82f7ecb6f7f6a00a55f2c2bbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmio_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a9874bbe82f7ecb6f7f6a00a55f2c2bbc">make_observer</a> (T *p)</td></tr>
<tr class="separator:a9874bbe82f7ecb6f7f6a00a55f2c2bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855a4c8ec365d7d6cc6e866b57ea2d1b"><td class="memTemplParams" colspan="2">template&lt;class Iter1 , class Iter2 &gt; </td></tr>
<tr class="memitem:a855a4c8ec365d7d6cc6e866b57ea2d1b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a855a4c8ec365d7d6cc6e866b57ea2d1b">make_range</a> (Iter1 &amp;&amp;iter1, Iter2 &amp;&amp;iter2)</td></tr>
<tr class="separator:a855a4c8ec365d7d6cc6e866b57ea2d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac160949c78aa17040a7b44c22754192b"><td class="memTemplParams" colspan="2">template&lt;class IterPair &gt; </td></tr>
<tr class="memitem:ac160949c78aa17040a7b44c22754192b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ac160949c78aa17040a7b44c22754192b">make_range</a> (IterPair &amp;&amp;p)</td></tr>
<tr class="memdesc:ac160949c78aa17040a7b44c22754192b"><td class="mdescLeft">&#160;</td><td class="mdescRight">factories for template argument deduction  <a href="namespacemio.html#ac160949c78aa17040a7b44c22754192b">More...</a><br /></td></tr>
<tr class="separator:ac160949c78aa17040a7b44c22754192b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69193b9fd2a0c3023d640082470a9ea0"><td class="memTemplParams" colspan="2">template&lt;class Rng , class F &gt; </td></tr>
<tr class="memitem:a69193b9fd2a0c3023d640082470a9ea0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a69193b9fd2a0c3023d640082470a9ea0">map</a> (const Rng &amp;v, F f)</td></tr>
<tr class="memdesc:a69193b9fd2a0c3023d640082470a9ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a random access range (i.e.  <a href="namespacemio.html#a69193b9fd2a0c3023d640082470a9ea0">More...</a><br /></td></tr>
<tr class="separator:a69193b9fd2a0c3023d640082470a9ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f6645c13faf4749f34d7e6e191f9ac"><td class="memTemplParams" colspan="2">template&lt;class A , class B &gt; </td></tr>
<tr class="memitem:a97f6645c13faf4749f34d7e6e191f9ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a97f6645c13faf4749f34d7e6e191f9ac">max</a> (const Eigen::MatrixBase&lt; A &gt; &amp;a, B &amp;&amp;b)</td></tr>
<tr class="memdesc:a97f6645c13faf4749f34d7e6e191f9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">coefficient wise maximum of two matrices.  <a href="namespacemio.html#a97f6645c13faf4749f34d7e6e191f9ac">More...</a><br /></td></tr>
<tr class="separator:a97f6645c13faf4749f34d7e6e191f9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9304db76fa4a82e64322fb206d956c"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a2d9304db76fa4a82e64322fb206d956c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a2d9304db76fa4a82e64322fb206d956c">minor_size</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:a2d9304db76fa4a82e64322fb206d956c"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of columns (rows) of a row (column) major matrix.  <a href="namespacemio.html#a2d9304db76fa4a82e64322fb206d956c">More...</a><br /></td></tr>
<tr class="separator:a2d9304db76fa4a82e64322fb206d956c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebb31121953c36c5b5b42976df8bcad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmio_1_1Date.html">Date</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#abebb31121953c36c5b5b42976df8bcad">offset_date_by_days</a> (<a class="el" href="structmio_1_1Date.html">Date</a> date, int offset_days)</td></tr>
<tr class="memdesc:abebb31121953c36c5b5b42976df8bcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the new date corresponding to a given date and a offset in days.  <a href="namespacemio.html#abebb31121953c36c5b5b42976df8bcad">More...</a><br /></td></tr>
<tr class="separator:abebb31121953c36c5b5b42976df8bcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9249591dc1922dcbff6ebb7746bee7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1c9249591dc1922dcbff6ebb7746bee7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacemio.html#af8c639c34c4df5647f084fefb48afc6e">has_eq_op</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a1c9249591dc1922dcbff6ebb7746bee7">operator!=</a> (const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e1, const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e2)</td></tr>
<tr class="separator:a1c9249591dc1922dcbff6ebb7746bee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af4730337dd5d430e3d09e4a88c09b5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5af4730337dd5d430e3d09e4a88c09b5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacemio.html#af8c639c34c4df5647f084fefb48afc6e">has_eq_op</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a5af4730337dd5d430e3d09e4a88c09b5">operator!=</a> (const <a class="el" href="structmio_1_1Node.html">Node</a>&lt; T &gt; &amp;n1, const <a class="el" href="structmio_1_1Node.html">Node</a>&lt; T &gt; &amp;n2)</td></tr>
<tr class="separator:a5af4730337dd5d430e3d09e4a88c09b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8d13d4bfbc6ab42cccb685cafdc5fe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5b8d13d4bfbc6ab42cccb685cafdc5fe"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacemio.html#a828f9a1016d1048d5d3e67dcc5ff4e8f">has_ostream_op</a>&lt; T &gt;::value, std::ostream &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a5b8d13d4bfbc6ab42cccb685cafdc5fe">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e)</td></tr>
<tr class="memdesc:a5b8d13d4bfbc6ab42cccb685cafdc5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">out stream operator for edges if edge property type has stream operator defined  <a href="namespacemio.html#a5b8d13d4bfbc6ab42cccb685cafdc5fe">More...</a><br /></td></tr>
<tr class="separator:a5b8d13d4bfbc6ab42cccb685cafdc5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a58db8b765e525595174fe5b502bf85"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9a58db8b765e525595174fe5b502bf85"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespacemio.html#a828f9a1016d1048d5d3e67dcc5ff4e8f">has_ostream_op</a>&lt; T &gt;::value, std::ostream &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a9a58db8b765e525595174fe5b502bf85">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e)</td></tr>
<tr class="memdesc:a9a58db8b765e525595174fe5b502bf85"><td class="mdescLeft">&#160;</td><td class="mdescRight">out stream operator for edges if edge property type does not have stream operator defined  <a href="namespacemio.html#a9a58db8b765e525595174fe5b502bf85">More...</a><br /></td></tr>
<tr class="separator:a9a58db8b765e525595174fe5b502bf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d44315af9f65cbb43ea90af7f1fae30"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2d44315af9f65cbb43ea90af7f1fae30"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacemio.html#af8c639c34c4df5647f084fefb48afc6e">has_eq_op</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a2d44315af9f65cbb43ea90af7f1fae30">operator==</a> (const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e1, const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e2)</td></tr>
<tr class="memdesc:a2d44315af9f65cbb43ea90af7f1fae30"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator if edge property type is equality comparable  <a href="namespacemio.html#a2d44315af9f65cbb43ea90af7f1fae30">More...</a><br /></td></tr>
<tr class="separator:a2d44315af9f65cbb43ea90af7f1fae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5eed69a2714509b05344ebd743543e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abf5eed69a2714509b05344ebd743543e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacemio.html#af8c639c34c4df5647f084fefb48afc6e">has_eq_op</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#abf5eed69a2714509b05344ebd743543e">operator==</a> (const <a class="el" href="structmio_1_1Node.html">Node</a>&lt; T &gt; &amp;n1, const <a class="el" href="structmio_1_1Node.html">Node</a>&lt; T &gt; &amp;n2)</td></tr>
<tr class="memdesc:abf5eed69a2714509b05344ebd743543e"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator if node property type is equality comparable  <a href="namespacemio.html#abf5eed69a2714509b05344ebd743543e">More...</a><br /></td></tr>
<tr class="separator:abf5eed69a2714509b05344ebd743543e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8630d8af93b95cc04f1f60ec774a425b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; <a class="el" href="structmio_1_1Date.html">Date</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a8630d8af93b95cc04f1f60ec774a425b">parse_date</a> (const std::string &amp;date_str)</td></tr>
<tr class="memdesc:a8630d8af93b95cc04f1f60ec774a425b"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses a date from a string.  <a href="namespacemio.html#a8630d8af93b95cc04f1f60ec774a425b">More...</a><br /></td></tr>
<tr class="separator:a8630d8af93b95cc04f1f60ec774a425b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d271b1fc1bc5f9ef54eb91c695f239"><td class="memTemplParams" colspan="2">template&lt;class String , class... Strings&gt; </td></tr>
<tr class="memitem:ad5d271b1fc1bc5f9ef54eb91c695f239"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ad5d271b1fc1bc5f9ef54eb91c695f239">path_join</a> (String &amp;&amp;base, Strings &amp;&amp;... app)</td></tr>
<tr class="memdesc:ad5d271b1fc1bc5f9ef54eb91c695f239"><td class="mdescLeft">&#160;</td><td class="mdescRight">join one ore more strings with path separators.  <a href="namespacemio.html#ad5d271b1fc1bc5f9ef54eb91c695f239">More...</a><br /></td></tr>
<tr class="separator:ad5d271b1fc1bc5f9ef54eb91c695f239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fb690ce687ea46e1d39decd0256e71"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a48fb690ce687ea46e1d39decd0256e71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a48fb690ce687ea46e1d39decd0256e71">print_graph</a> (std::ostream &amp;os, const <a class="el" href="classmio_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="separator:a48fb690ce687ea46e1d39decd0256e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff056f6334958caaeb57f839f718c23"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aeff056f6334958caaeb57f839f718c23"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespacemio.html#a828f9a1016d1048d5d3e67dcc5ff4e8f">has_ostream_op</a>&lt; T &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aeff056f6334958caaeb57f839f718c23">print_graph_object</a> (std::ostream &amp;os, size_t idx, const T &amp;)</td></tr>
<tr class="separator:aeff056f6334958caaeb57f839f718c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51670ce4ee6cf980fa675af2076a6da7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a51670ce4ee6cf980fa675af2076a6da7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacemio.html#a828f9a1016d1048d5d3e67dcc5ff4e8f">has_ostream_op</a>&lt; T &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a51670ce4ee6cf980fa675af2076a6da7">print_graph_object</a> (std::ostream &amp;os, size_t idx, const T &amp;o)</td></tr>
<tr class="separator:a51670ce4ee6cf980fa675af2076a6da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88d8b5328998d7bd587ee9fdb01264b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#ac88d8b5328998d7bd587ee9fdb01264b">PrintTo</a> (const <a class="el" href="classmio_1_1IOStatus.html">IOStatus</a> &amp;status, std::ostream *os)</td></tr>
<tr class="memdesc:ac88d8b5328998d7bd587ee9fdb01264b"><td class="mdescLeft">&#160;</td><td class="mdescRight">gtest printer for <a class="el" href="classmio_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a>.  <a href="namespacemio.html#ac88d8b5328998d7bd587ee9fdb01264b">More...</a><br /></td></tr>
<tr class="separator:ac88d8b5328998d7bd587ee9fdb01264b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af925d286771dec772a63ca778c022ff4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#af925d286771dec772a63ca778c022ff4">PrintTo</a> (const <a class="el" href="classmio_1_1UncertainValue.html">UncertainValue</a> &amp;uv, std::ostream *os)</td></tr>
<tr class="separator:af925d286771dec772a63ca778c022ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec62c6bfbabd61f08d7653ad015019b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#aeec62c6bfbabd61f08d7653ad015019b">read_mobility_formatted</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:aeec62c6bfbabd61f08d7653ad015019b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads formatted migration or contact data which is given in columns from_str to_str from_rs to_rs count_abs and separated by tabs.  <a href="namespacemio.html#aeec62c6bfbabd61f08d7653ad015019b">More...</a><br /></td></tr>
<tr class="separator:aeec62c6bfbabd61f08d7653ad015019b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a8796a9d01a72a28ac34b1aa1332b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#af9a8796a9d01a72a28ac34b1aa1332b4">read_mobility_plain</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:af9a8796a9d01a72a28ac34b1aa1332b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads txt migration data or contact which is given by values only and separated by spaces.  <a href="namespacemio.html#af9a8796a9d01a72a28ac34b1aa1332b4">More...</a><br /></td></tr>
<tr class="separator:af9a8796a9d01a72a28ac34b1aa1332b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd64a3ccb4b0435e7de0f3afef289ea"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a2cd64a3ccb4b0435e7de0f3afef289ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a2cd64a3ccb4b0435e7de0f3afef289ea">reshape</a> (M &amp;&amp;m, Eigen::Index rows, Eigen::Index cols)</td></tr>
<tr class="memdesc:a2cd64a3ccb4b0435e7de0f3afef289ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">reshape the matrix.  <a href="namespacemio.html#a2cd64a3ccb4b0435e7de0f3afef289ea">More...</a><br /></td></tr>
<tr class="separator:a2cd64a3ccb4b0435e7de0f3afef289ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa85830d7050b8ecdc6d2ae664b74290"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#afa85830d7050b8ecdc6d2ae664b74290">result_distance_2norm</a> (const std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">mio::TimeSeries</a>&lt; double &gt;&gt; &amp;result1, const std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">mio::TimeSeries</a>&lt; double &gt;&gt; &amp;result2)</td></tr>
<tr class="memdesc:afa85830d7050b8ecdc6d2ae664b74290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance between two SECIR simulation results.  <a href="namespacemio.html#afa85830d7050b8ecdc6d2ae664b74290">More...</a><br /></td></tr>
<tr class="separator:afa85830d7050b8ecdc6d2ae664b74290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721ec86366e54b94f1d34bfbf6c8a806"><td class="memTemplParams" colspan="2">template&lt;class InfectionState &gt; </td></tr>
<tr class="memitem:a721ec86366e54b94f1d34bfbf6c8a806"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a721ec86366e54b94f1d34bfbf6c8a806">result_distance_2norm</a> (const std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">mio::TimeSeries</a>&lt; double &gt;&gt; &amp;result1, const std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">mio::TimeSeries</a>&lt; double &gt;&gt; &amp;result2, InfectionState compartment)</td></tr>
<tr class="memdesc:a721ec86366e54b94f1d34bfbf6c8a806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance between two compartment model simulation results in one compartment.  <a href="namespacemio.html#a721ec86366e54b94f1d34bfbf6c8a806">More...</a><br /></td></tr>
<tr class="separator:a721ec86366e54b94f1d34bfbf6c8a806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a24b9e6cb629e04e9613446f07d6ba"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T &gt; </td></tr>
<tr class="memitem:a27a24b9e6cb629e04e9613446f07d6ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a27a24b9e6cb629e04e9613446f07d6ba">serialize</a> (IOContext &amp;io, const T &amp;t)</td></tr>
<tr class="memdesc:a27a24b9e6cb629e04e9613446f07d6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save data that describes an object in a format determined by the given context.  <a href="namespacemio.html#a27a24b9e6cb629e04e9613446f07d6ba">More...</a><br /></td></tr>
<tr class="separator:a27a24b9e6cb629e04e9613446f07d6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960fc458f9dc3a8a39e13a54735dcdee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a960fc458f9dc3a8a39e13a54735dcdee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmio_1_1ByteStream.html">ByteStream</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a960fc458f9dc3a8a39e13a54735dcdee">serialize_binary</a> (const T &amp;t, int flags=0)</td></tr>
<tr class="memdesc:a960fc458f9dc3a8a39e13a54735dcdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an object into binary format.  <a href="namespacemio.html#a960fc458f9dc3a8a39e13a54735dcdee">More...</a><br /></td></tr>
<tr class="separator:a960fc458f9dc3a8a39e13a54735dcdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad073fd426ea5971baa4f6959f1244d0e"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class Container , std::enable_if_t&lt; conjunction_v&lt; is_container&lt; Container &gt;, negation&lt; has_serialize&lt; IOContext, Container &gt;&gt;&gt;, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ad073fd426ea5971baa4f6959f1244d0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ad073fd426ea5971baa4f6959f1244d0e">serialize_internal</a> (IOContext &amp;io, const Container &amp;container)</td></tr>
<tr class="memdesc:ad073fd426ea5971baa4f6959f1244d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize an STL compatible container.  <a href="namespacemio.html#ad073fd426ea5971baa4f6959f1244d0e">More...</a><br /></td></tr>
<tr class="separator:ad073fd426ea5971baa4f6959f1244d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123611af57e5e17defecde4498b0a25c"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class M &gt; </td></tr>
<tr class="memitem:a123611af57e5e17defecde4498b0a25c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a123611af57e5e17defecde4498b0a25c">serialize_internal</a> (IOContext &amp;io, const Eigen::EigenBase&lt; M &gt; &amp;mat)</td></tr>
<tr class="memdesc:a123611af57e5e17defecde4498b0a25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize an Eigen matrix expression.  <a href="namespacemio.html#a123611af57e5e17defecde4498b0a25c">More...</a><br /></td></tr>
<tr class="separator:a123611af57e5e17defecde4498b0a25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c89be42d282d1da23ce443c09e9e74"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T , std::enable_if_t&lt; is_expression_valid&lt; serialize_t, IOContext, T &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a17c89be42d282d1da23ce443c09e9e74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a17c89be42d282d1da23ce443c09e9e74">serialize_internal</a> (IOContext &amp;io, const T &amp;t)</td></tr>
<tr class="memdesc:a17c89be42d282d1da23ce443c09e9e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize an object that has a serialize(io) member function.  <a href="namespacemio.html#a17c89be42d282d1da23ce443c09e9e74">More...</a><br /></td></tr>
<tr class="separator:a17c89be42d282d1da23ce443c09e9e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f158d720a7cadd39e482f6c2302a087"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class Tup , class  = std::enable_if_t&lt;is_expression_valid&lt;details::tuple_size_value_t, Tup&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a9f158d720a7cadd39e482f6c2302a087"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a9f158d720a7cadd39e482f6c2302a087">serialize_internal</a> (IOContext &amp;io, const Tup &amp;tup)</td></tr>
<tr class="memdesc:a9f158d720a7cadd39e482f6c2302a087"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize a tuple-like object, e.g.  <a href="namespacemio.html#a9f158d720a7cadd39e482f6c2302a087">More...</a><br /></td></tr>
<tr class="separator:a9f158d720a7cadd39e482f6c2302a087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e3cf3f2cc4c651d581573f57331229"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class E , std::enable_if_t&lt; std::is_enum&lt; E &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ad6e3cf3f2cc4c651d581573f57331229"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#ad6e3cf3f2cc4c651d581573f57331229">serialize_internal</a> (IOContext &amp;io, E e)</td></tr>
<tr class="memdesc:ad6e3cf3f2cc4c651d581573f57331229"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize an enum value as its underlying type.  <a href="namespacemio.html#ad6e3cf3f2cc4c651d581573f57331229">More...</a><br /></td></tr>
<tr class="separator:ad6e3cf3f2cc4c651d581573f57331229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f42fd4fd378be54e349ec0043efeb1d"><td class="memTemplParams" colspan="2">template&lt;class ContactLocation , class Model , class MigrationParams , class MigrationCoefficientGroup , class InfectionState , class ReadFunction &gt; </td></tr>
<tr class="memitem:a8f42fd4fd378be54e349ec0043efeb1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a8f42fd4fd378be54e349ec0043efeb1d">set_edges</a> (const fs::path &amp;data_dir, <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; Model, MigrationParams &gt; &amp;params_graph, std::initializer_list&lt; InfectionState &gt; &amp;migrating_compartments, size_t contact_locations_size, ReadFunction &amp;&amp;read_func, std::vector&lt; <a class="el" href="config_8h.html#acd4f1d492d83a74716a42615e127d641">ScalarType</a> &gt; commuting_weights=std::vector&lt; <a class="el" href="config_8h.html#acd4f1d492d83a74716a42615e127d641">ScalarType</a> &gt;{})</td></tr>
<tr class="memdesc:a8f42fd4fd378be54e349ec0043efeb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the graph edges.  <a href="namespacemio.html#a8f42fd4fd378be54e349ec0043efeb1d">More...</a><br /></td></tr>
<tr class="separator:a8f42fd4fd378be54e349ec0043efeb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76d1d8f469ab547ed1ceb5e8c96f271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#ac76d1d8f469ab547ed1ceb5e8c96f271">set_log_level</a> (<a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220">LogLevel</a> level)</td></tr>
<tr class="memdesc:ac76d1d8f469ab547ed1ceb5e8c96f271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the verbosity of the logger.  <a href="namespacemio.html#ac76d1d8f469ab547ed1ceb5e8c96f271">More...</a><br /></td></tr>
<tr class="separator:ac76d1d8f469ab547ed1ceb5e8c96f271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62370f41f294bb6b3a1f32fc7a37473c"><td class="memTemplParams" colspan="2">template&lt;class TestAndTrace , class ContactPattern , class Model , class MigrationParams , class Parameters , class ReadFunction , class NodeIdFunction &gt; </td></tr>
<tr class="memitem:a62370f41f294bb6b3a1f32fc7a37473c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a62370f41f294bb6b3a1f32fc7a37473c">set_nodes</a> (const Parameters &amp;params, <a class="el" href="structmio_1_1Date.html">Date</a> start_date, <a class="el" href="structmio_1_1Date.html">Date</a> end_date, const fs::path &amp;data_dir, const std::string &amp;population_data_path, bool is_node_for_county, <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; Model, MigrationParams &gt; &amp;params_graph, ReadFunction &amp;&amp;read_func, NodeIdFunction &amp;&amp;node_func, const std::vector&lt; double &gt; &amp;scaling_factor_inf, double scaling_factor_icu, double tnt_capacity_factor, int num_days=0, bool export_time_series=false)</td></tr>
<tr class="memdesc:a62370f41f294bb6b3a1f32fc7a37473c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the graph nodes for counties or districts.  <a href="namespacemio.html#a62370f41f294bb6b3a1f32fc7a37473c">More...</a><br /></td></tr>
<tr class="separator:a62370f41f294bb6b3a1f32fc7a37473c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf026dd6066d8d0e413fb754082a2dd2"><td class="memTemplParams" colspan="2">template&lt;class Model , class Sim  = Simulation&lt;Model&gt;&gt; </td></tr>
<tr class="memitem:adf026dd6066d8d0e413fb754082a2dd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; <a class="el" href="config_8h.html#acd4f1d492d83a74716a42615e127d641">ScalarType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#adf026dd6066d8d0e413fb754082a2dd2">simulate</a> (double t0, double tmax, double dt, Model const &amp;model, std::shared_ptr&lt; <a class="el" href="classmio_1_1IntegratorCore.html">IntegratorCore</a> &gt; integrator=nullptr)</td></tr>
<tr class="memdesc:adf026dd6066d8d0e413fb754082a2dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">simulate simulates a compartmental model  <a href="namespacemio.html#adf026dd6066d8d0e413fb754082a2dd2">More...</a><br /></td></tr>
<tr class="separator:adf026dd6066d8d0e413fb754082a2dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad68521b3c371e12d598418900b3049d"><td class="memTemplParams" colspan="2">template&lt;class M , std::enable_if_t&lt; is_dynamic_matrix&lt; M &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aad68521b3c371e12d598418900b3049d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#aad68521b3c371e12d598418900b3049d">slice</a> (M &amp;&amp;m, <a class="el" href="structmio_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt; rows, <a class="el" href="structmio_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt; cols)</td></tr>
<tr class="memdesc:aad68521b3c371e12d598418900b3049d"><td class="mdescLeft">&#160;</td><td class="mdescRight">take a regular slice of a matrix.  <a href="namespacemio.html#aad68521b3c371e12d598418900b3049d">More...</a><br /></td></tr>
<tr class="separator:aad68521b3c371e12d598418900b3049d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743eeec3a91821cb14fd831740b17827"><td class="memTemplParams" colspan="2">template&lt;class V , std::enable_if_t&lt; is_dynamic_vector&lt; V &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a743eeec3a91821cb14fd831740b17827"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a743eeec3a91821cb14fd831740b17827">slice</a> (V &amp;&amp;v, <a class="el" href="structmio_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt; elems)</td></tr>
<tr class="memdesc:a743eeec3a91821cb14fd831740b17827"><td class="mdescLeft">&#160;</td><td class="mdescRight">take a regular slice of a row or column vector.  <a href="namespacemio.html#a743eeec3a91821cb14fd831740b17827">More...</a><br /></td></tr>
<tr class="separator:a743eeec3a91821cb14fd831740b17827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ea68c2bc0b216f8ffeb9c5a53ea49a"><td class="memTemplParams" colspan="2">template&lt;class LeftExpr , class RightExpr &gt; </td></tr>
<tr class="memitem:a73ea68c2bc0b216f8ffeb9c5a53ea49a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a73ea68c2bc0b216f8ffeb9c5a53ea49a">smoother_cosine</a> (double x, double xleft, double xright, const Eigen::MatrixBase&lt; LeftExpr &gt; &amp;yleft_expr, const Eigen::MatrixBase&lt; RightExpr &gt; &amp;yright_expr)</td></tr>
<tr class="memdesc:a73ea68c2bc0b216f8ffeb9c5a53ea49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">smoother_cosine as a matrix valued function.  <a href="namespacemio.html#a73ea68c2bc0b216f8ffeb9c5a53ea49a">More...</a><br /></td></tr>
<tr class="separator:a73ea68c2bc0b216f8ffeb9c5a53ea49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472d6437e9b34e277b8ccc551b0630b8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a472d6437e9b34e277b8ccc551b0630b8">smoother_cosine</a> (double x, double xleft, double xright, double yleft, double yright)</td></tr>
<tr class="memdesc:a472d6437e9b34e277b8ccc551b0630b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smoothed evaluation of a discrete jump of function values <br  />
 yleft and yright on xleft and xright, respectively, by using a cosine function.  <a href="namespacemio.html#a472d6437e9b34e277b8ccc551b0630b8">More...</a><br /></td></tr>
<tr class="separator:a472d6437e9b34e277b8ccc551b0630b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d968bb8ec90f4bdbf8bfbee2a98ccb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#aa5d968bb8ec90f4bdbf8bfbee2a98ccb">split</a> (const std::string &amp;s, char delimiter)</td></tr>
<tr class="memdesc:aa5d968bb8ec90f4bdbf8bfbee2a98ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits string into a Vector of strings according to delimiter.  <a href="namespacemio.html#aa5d968bb8ec90f4bdbf8bfbee2a98ccb">More...</a><br /></td></tr>
<tr class="separator:aa5d968bb8ec90f4bdbf8bfbee2a98ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a4eb6dbb5992d29976faefcdd5b78c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmio_1_1detail_1_1StatusCodeCategory.html">detail::StatusCodeCategory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#ad3a4eb6dbb5992d29976faefcdd5b78c">status_code_category</a> ()</td></tr>
<tr class="memdesc:ad3a4eb6dbb5992d29976faefcdd5b78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">singleton StatusCodeCategory instance.  <a href="namespacemio.html#ad3a4eb6dbb5992d29976faefcdd5b78c">More...</a><br /></td></tr>
<tr class="separator:ad3a4eb6dbb5992d29976faefcdd5b78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d7fd30c9669e05b537b2caedd82bb8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a80d7fd30c9669e05b537b2caedd82bb8">success</a> ()</td></tr>
<tr class="memdesc:a80d7fd30c9669e05b537b2caedd82bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object that is implicitly convertible to a succesful IOResult&lt;void&gt;.  <a href="namespacemio.html#a80d7fd30c9669e05b537b2caedd82bb8">More...</a><br /></td></tr>
<tr class="separator:a80d7fd30c9669e05b537b2caedd82bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cc59d9b2500df07a248ff1fd2b7367"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a98cc59d9b2500df07a248ff1fd2b7367"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a98cc59d9b2500df07a248ff1fd2b7367">success</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:a98cc59d9b2500df07a248ff1fd2b7367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object that is implicitly convertible to a succesful IOResult.  <a href="namespacemio.html#a98cc59d9b2500df07a248ff1fd2b7367">More...</a><br /></td></tr>
<tr class="separator:a98cc59d9b2500df07a248ff1fd2b7367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc993280be5018864892fb24b3e9f18"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a4bc993280be5018864892fb24b3e9f18">sum_nodes</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;ensemble_result)</td></tr>
<tr class="separator:a4bc993280be5018864892fb24b3e9f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb526164db4b433fe9e65133f20edd3d"><td class="memTemplParams" colspan="2">template&lt;class Sim , std::enable_if_t&lt;!is_expression_valid&lt; test_commuters_expr_t, Sim &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:adb526164db4b433fe9e65133f20edd3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#adb526164db4b433fe9e65133f20edd3d">test_commuters</a> (<a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;, Eigen::Ref&lt; Eigen::VectorXd &gt;, double)</td></tr>
<tr class="memdesc:adb526164db4b433fe9e65133f20edd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test persons when migrating from their source node.  <a href="namespacemio.html#adb526164db4b433fe9e65133f20edd3d">More...</a><br /></td></tr>
<tr class="separator:adb526164db4b433fe9e65133f20edd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d12da511334eeca8b76dda616efd25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmio_1_1RandomNumberGenerator.html">RandomNumberGenerator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemio.html#a39d12da511334eeca8b76dda616efd25">thread_local_rng</a> ()</td></tr>
<tr class="memdesc:a39d12da511334eeca8b76dda616efd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a random number generator that is static and local to this thread.  <a href="namespacemio.html#a39d12da511334eeca8b76dda616efd25">More...</a><br /></td></tr>
<tr class="separator:a39d12da511334eeca8b76dda616efd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fab9e6d67aeaa98bb74dac0d52ac4fc"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:a9fab9e6d67aeaa98bb74dac0d52ac4fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a9fab9e6d67aeaa98bb74dac0d52ac4fc">unused</a> (T &amp;&amp;...)</td></tr>
<tr class="memdesc:a9fab9e6d67aeaa98bb74dac0d52ac4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">does nothing, can be used to mark variables as not used.  <a href="namespacemio.html#a9fab9e6d67aeaa98bb74dac0d52ac4fc">More...</a><br /></td></tr>
<tr class="separator:a9fab9e6d67aeaa98bb74dac0d52ac4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9afccd5e6410c704b1565079e5837d80"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:a9afccd5e6410c704b1565079e5837d80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmio_1_1GraphSimulation.html">GraphSimulation</a>&lt; <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a9afccd5e6410c704b1565079e5837d80">make_migration_sim</a> (double t0, double dt, const <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a> &gt; &amp;graph)</td></tr>
<tr class="memdesc:a9afccd5e6410c704b1565079e5837d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a migration simulation.  <a href="namespacemio.html#a9afccd5e6410c704b1565079e5837d80">More...</a><br /></td></tr>
<tr class="separator:a9afccd5e6410c704b1565079e5837d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7abb9f1e2b136f146af558abba7e28"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:acb7abb9f1e2b136f146af558abba7e28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmio_1_1GraphSimulation.html">GraphSimulation</a>&lt; <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#acb7abb9f1e2b136f146af558abba7e28">make_migration_sim</a> (double t0, double dt, <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a> &gt; &amp;&amp;graph)</td></tr>
<tr class="separator:acb7abb9f1e2b136f146af558abba7e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a718336dfc617e9dbb8b7e1d29050861b"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:a718336dfc617e9dbb8b7e1d29050861b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmio_1_1GraphSimulationStochastic.html">GraphSimulationStochastic</a>&lt; <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdgeStochastic.html">MigrationEdgeStochastic</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a718336dfc617e9dbb8b7e1d29050861b">make_migration_sim</a> (double t0, double dt, const <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdgeStochastic.html">MigrationEdgeStochastic</a> &gt; &amp;graph)</td></tr>
<tr class="memdesc:a718336dfc617e9dbb8b7e1d29050861b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a migration simulation.  <a href="namespacemio.html#a718336dfc617e9dbb8b7e1d29050861b">More...</a><br /></td></tr>
<tr class="separator:a718336dfc617e9dbb8b7e1d29050861b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ddabba17ee78ac0b4a3e380b9c4f39"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:a29ddabba17ee78ac0b4a3e380b9c4f39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmio_1_1GraphSimulationStochastic.html">GraphSimulationStochastic</a>&lt; <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdgeStochastic.html">MigrationEdgeStochastic</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a29ddabba17ee78ac0b4a3e380b9c4f39">make_migration_sim</a> (double t0, double dt, <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdgeStochastic.html">MigrationEdgeStochastic</a> &gt; &amp;&amp;graph)</td></tr>
<tr class="separator:a29ddabba17ee78ac0b4a3e380b9c4f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a556fe87bb4d69609a931d684a863568c"><td class="memTemplParams" colspan="2">template&lt;class Iter , class Transform &gt; </td></tr>
<tr class="memitem:a556fe87bb4d69609a931d684a863568c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a556fe87bb4d69609a931d684a863568c">make_transform_iterator</a> (Iter &amp;&amp;iter, Transform &amp;&amp;transform)</td></tr>
<tr class="memdesc:a556fe87bb4d69609a931d684a863568c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classmio_1_1TransformIterator.html" title="Iterator that transforms the values produced by an underlying iterator.">TransformIterator</a>.  <a href="namespacemio.html#a556fe87bb4d69609a931d684a863568c">More...</a><br /></td></tr>
<tr class="separator:a556fe87bb4d69609a931d684a863568c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a12844b1c358ec3b74eba28dc795087fd"><td class="memTemplParams" colspan="2">template&lt;class Trait &gt; </td></tr>
<tr class="memitem:a12844b1c358ec3b74eba28dc795087fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a12844b1c358ec3b74eba28dc795087fd">negation_v</a> = <a class="el" href="structmio_1_1negation.html">negation</a>&lt;Trait&gt;::value</td></tr>
<tr class="separator:a12844b1c358ec3b74eba28dc795087fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5e1169fe9e5d36e1c3a2bf558a874049"><td class="memTemplParams" colspan="2">template&lt;class... Bs&gt; </td></tr>
<tr class="memitem:a5e1169fe9e5d36e1c3a2bf558a874049"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a5e1169fe9e5d36e1c3a2bf558a874049">conjunction_v</a> = <a class="el" href="structmio_1_1conjunction.html">conjunction</a>&lt;Bs...&gt;::value</td></tr>
<tr class="separator:a5e1169fe9e5d36e1c3a2bf558a874049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a051882939b25c74a4d3fd2cad852a942"><td class="memTemplParams" colspan="2">template&lt;class... Bn&gt; </td></tr>
<tr class="memitem:a051882939b25c74a4d3fd2cad852a942"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemio.html#a051882939b25c74a4d3fd2cad852a942">disjunction_v</a> = <a class="el" href="structmio_1_1disjunction.html">disjunction</a>&lt;Bn...&gt;::value</td></tr>
<tr class="separator:a051882939b25c74a4d3fd2cad852a942"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collection of classes to simplify handling of matrix shapes in meta programming. </p>
<p>Matrix shape types follow this model:</p><ul>
<li>subtype Matrix that is an alias of an Eigen matrix type</li>
<li>at least one constructor that sets the shape from dimensions</li>
<li>static member function <code>get_shape_of</code> that takes a compatible matrix expression and returns it's shape</li>
<li>const member functions rows() and cols()</li>
<li>trivially copyable, moveable, assignable, move assignable</li>
<li>equality comparable </li>
</ul>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="af15ba49097f82eae310c5ed3d21a1b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15ba49097f82eae310c5ed3d21a1b4b">&#9670;&nbsp;</a></span>advance_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#af15ba49097f82eae310c5ed3d21a1b4b">mio::advance_expr_t</a> = typedef decltype(std::declval&lt;Sim&gt;().advance(std::declval&lt;double&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the return type of the <code>advance</code> member function of a type. </p>
<p>Template is invalid if this member function does not exist. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sim</td><td>a compartment model simulation type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8b64973f63b24b787e11ddbbb5f8dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b64973f63b24b787e11ddbbb5f8dc3">&#9670;&nbsp;</a></span>ConstParameterDistributionVisitor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#ad8b64973f63b24b787e11ddbbb5f8dc3">mio::ConstParameterDistributionVisitor</a> = typedef <a class="el" href="structmio_1_1ConstVisitor.html">ConstVisitor</a>&lt;class <a class="el" href="classmio_1_1ParameterDistributionNormal.html">ParameterDistributionNormal</a>, class <a class="el" href="classmio_1_1ParameterDistributionUniform.html">ParameterDistributionUniform</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6d8d488db7199d4e87910999c8b30ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d8d488db7199d4e87910999c8b30ec">&#9670;&nbsp;</a></span>CVPlainMatrixT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#af6d8d488db7199d4e87910999c8b30ec">mio::CVPlainMatrixT</a> = typedef typename <a class="el" href="structmio_1_1CVPlainMatrix.html">CVPlainMatrix</a>&lt;M&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6164d4e8f4df5089a14e927650c5a638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6164d4e8f4df5089a14e927650c5a638">&#9670;&nbsp;</a></span>DerivFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a6164d4e8f4df5089a14e927650c5a638">mio::DerivFunction</a> = typedef std::function&lt;void(Eigen::Ref&lt;const Eigen::VectorXd&gt; y, double t, Eigen::Ref&lt;Eigen::VectorXd&gt; dydt)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function template to be integrated. </p>

</div>
</div>
<a id="a8bc3cbccffee821ee8b3d10fceb36d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc3cbccffee821ee8b3d10fceb36d1e">&#9670;&nbsp;</a></span>deserialize_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a8bc3cbccffee821ee8b3d10fceb36d1e">mio::deserialize_t</a> = typedef decltype(T::deserialize(std::declval&lt;IOContext&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a650d53c2712e3249c7f9fdac228e664f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650d53c2712e3249c7f9fdac228e664f">&#9670;&nbsp;</a></span>DiscreteDistribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a650d53c2712e3249c7f9fdac228e664f">mio::DiscreteDistribution</a> = typedef <a class="el" href="classmio_1_1DistributionAdapter.html">DistributionAdapter</a>&lt;<a class="el" href="classmio_1_1DiscreteDistributionInPlace.html">DiscreteDistributionInPlace</a>&lt;Int&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adapted discrete distribution </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmio_1_1DistributionAdapter.html" title="adapter for a random number distribution.">DistributionAdapter</a> </dd></dl>

</div>
</div>
<a id="a628e7270083870520c65318b8c5f2efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628e7270083870520c65318b8c5f2efd">&#9670;&nbsp;</a></span>eq_op_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a628e7270083870520c65318b8c5f2efd">mio::eq_op_t</a> = typedef decltype(std::declval&lt;T&gt;() == std::declval&lt;T&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>meta function to check type T for an existing equality comparison operator </p>

</div>
</div>
<a id="a27dab8db023c553df90eb71275843f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dab8db023c553df90eb71275843f41">&#9670;&nbsp;</a></span>eval_right_hand_side_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a27dab8db023c553df90eb71275843f41">mio::eval_right_hand_side_expr_t</a> = typedef decltype(std::declval&lt;const M&amp;&gt;().eval_right_hand_side( std::declval&lt;Eigen::Ref&lt;const Eigen::VectorXd&gt; &gt;(), std::declval&lt;Eigen::Ref&lt;const Eigen::VectorXd&gt; &gt;(), std::declval&lt;double&gt;(), std::declval&lt;Eigen::Ref&lt;Eigen::VectorXd&gt; &gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>detect the eval_right_hand_side member function of a compartment model. </p>
<p>If the eval_right_hand_side member function exists in the type M, this template when instatiated will be equal to the return type of the function. Otherwise the template is invalid. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a type that has a eval_right_hand_side member function, e.g. a compartment model type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4116647943793f9c44b5e2c70ea1a84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4116647943793f9c44b5e2c70ea1a84e">&#9670;&nbsp;</a></span>ExponentialDistribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a4116647943793f9c44b5e2c70ea1a84e">mio::ExponentialDistribution</a> = typedef <a class="el" href="classmio_1_1DistributionAdapter.html">DistributionAdapter</a>&lt;std::exponential_distribution&lt;Real&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adapted std::exponential_distribution. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmio_1_1DistributionAdapter.html" title="adapter for a random number distribution.">DistributionAdapter</a> </dd></dl>

</div>
</div>
<a id="a97757b3eaa1d1cd6fe1550f26c291bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97757b3eaa1d1cd6fe1550f26c291bc5">&#9670;&nbsp;</a></span>get_infections_relative_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a97757b3eaa1d1cd6fe1550f26c291bc5">mio::get_infections_relative_expr_t</a> = typedef decltype(<a class="el" href="namespacemio.html#a85ab6b99636fa04a3d21cb8d08fc4c08">get_infections_relative</a>( std::declval&lt;const Sim&amp;&gt;(), std::declval&lt;double&gt;(), std::declval&lt;const Eigen::Ref&lt;const Eigen::VectorXd&gt;&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>detect a get_infections_relative function for the Model type. </p>

</div>
</div>
<a id="a861b27ba4067e505fdd45dec8087c169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861b27ba4067e505fdd45dec8087c169">&#9670;&nbsp;</a></span>get_initial_values_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a861b27ba4067e505fdd45dec8087c169">mio::get_initial_values_expr_t</a> = typedef decltype(std::declval&lt;Eigen::VectorXd&amp;&gt;() = std::declval&lt;const M&amp;&gt;().get_initial_values())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>detect the get_initial_values member function of a compartment model. </p>
<p>If the detect_initial_values member function exists in the type M, this template when instatiated will be equal to the return type of the function. Otherwise the template is invalid. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a type that has a get_initial_values member function, e.g. a compartment model type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55bf290db560dfa35968e2b286ff078f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bf290db560dfa35968e2b286ff078f">&#9670;&nbsp;</a></span>get_migration_factors_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a55bf290db560dfa35968e2b286ff078f">mio::get_migration_factors_expr_t</a> = typedef decltype(<a class="el" href="namespacemio.html#ab74f1d86f5a3421e7a971c22b50fd89c">get_migration_factors</a>( std::declval&lt;const Sim&amp;&gt;(), std::declval&lt;double&gt;(), std::declval&lt;const Eigen::Ref&lt;const Eigen::VectorXd&gt;&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>detect a get_migration_factors function for the Model type. </p>

</div>
</div>
<a id="a5f2af1294cf48bb782478c8d183031c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2af1294cf48bb782478c8d183031c0">&#9670;&nbsp;</a></span>has_apply_constraints_member_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a5f2af1294cf48bb782478c8d183031c0">mio::has_apply_constraints_member_function</a> = typedef <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespacemio_1_1details.html#a11800c3db22deebc6aa9f9d457c9add2">details::apply_constraints_expr_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether a apply_constraints function exists </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type to check for the existence of the member function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a376021d0dfbbf5639180b1fa30a26f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376021d0dfbbf5639180b1fa30a26f54">&#9670;&nbsp;</a></span>has_check_constraints_member_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a376021d0dfbbf5639180b1fa30a26f54">mio::has_check_constraints_member_function</a> = typedef <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespacemio_1_1details.html#a3718cd19964b2e578e34c903209a731f">details::check_constraints_expr_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether a check_constraints function exists </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type to check for the existence of the member function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32e1937fb0741f02d404d42fd061e37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e1937fb0741f02d404d42fd061e37c">&#9670;&nbsp;</a></span>has_deserialize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a32e1937fb0741f02d404d42fd061e37c">mio::has_deserialize</a> = typedef <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespacemio.html#a8bc3cbccffee821ee8b3d10fceb36d1e">deserialize_t</a>, IOContext, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8c639c34c4df5647f084fefb48afc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c639c34c4df5647f084fefb48afc6e">&#9670;&nbsp;</a></span>has_eq_op</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#af8c639c34c4df5647f084fefb48afc6e">mio::has_eq_op</a> = typedef <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespacemio.html#a628e7270083870520c65318b8c5f2efd">eq_op_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0781077265001b4d45934e1793982e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0781077265001b4d45934e1793982e5">&#9670;&nbsp;</a></span>has_get_default_member_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#aa0781077265001b4d45934e1793982e5">mio::has_get_default_member_function</a> = typedef <a class="el" href="structmio_1_1details_1_1has__get__default__member__function.html">details::has_get_default_member_function</a>&lt;T, void, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether a get_default function exists </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type to check for the existence of the member function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a828f9a1016d1048d5d3e67dcc5ff4e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828f9a1016d1048d5d3e67dcc5ff4e8f">&#9670;&nbsp;</a></span>has_ostream_op</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a828f9a1016d1048d5d3e67dcc5ff4e8f">mio::has_ostream_op</a> = typedef <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespacemio.html#a0c09d69095773d82728cea5345a40008">ostream_op_expr_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45b14b6a7d90203c53336d81ff946932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b14b6a7d90203c53336d81ff946932">&#9670;&nbsp;</a></span>has_serialize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a45b14b6a7d90203c53336d81ff946932">mio::has_serialize</a> = typedef <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespacemio.html#af1c9f969c0a8d114d1cfdff970cc99f9">serialize_t</a>, IOContext, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18e3295400f60de85bac8cc951d22cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e3295400f60de85bac8cc951d22cb3">&#9670;&nbsp;</a></span>HistoryWithMemoryWriter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Loggers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a18e3295400f60de85bac8cc951d22cb3">mio::HistoryWithMemoryWriter</a> = typedef <a class="el" href="classmio_1_1History.html">History</a>&lt;<a class="el" href="structmio_1_1DataWriterToMemory.html">DataWriterToMemory</a>, Loggers...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a802f35511c350a60fbd8838a6df5bd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802f35511c350a60fbd8838a6df5bd61">&#9670;&nbsp;</a></span>InterpolateResultT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a802f35511c350a60fbd8838a6df5bd61">mio::InterpolateResultT</a> = typedef std::decay_t&lt;decltype(<a class="el" href="namespacemio.html#a449f66b75f44f30dc4e70963355f9b5e">interpolate_simulation_result</a>(std::declval&lt;T&gt;()))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper template, type returned by overload interpolate_simulation_result(T t) </p>

</div>
</div>
<a id="ae556a666d14183eb2bf3a3efc11551ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae556a666d14183eb2bf3a3efc11551ec">&#9670;&nbsp;</a></span>IOResult</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">mio::IOResult</a> = typedef boost::outcome_v2::unchecked&lt;T, <a class="el" href="classmio_1_1IOStatus.html">IOStatus</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-or-error type for operations that return a value but can fail. </p>
<p>Can also be used for functions that return void so that all IO functions have compatible signatures. e.g. <code>IOResult&lt;int&gt; parse_int(const std::string&amp; s);</code> <code>IOResult&lt;void&gt; mkdir(const std::string&amp; path);</code></p>
<p>Create IOResult objects with:</p><ul>
<li><code>success(t)</code>, <code>failure(e)</code>: Create objects that store a T or <a class="el" href="classmio_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> and are implicitly convertible to IOResult. This is the easiest way to return from a function that returns an IOResult.</li>
<li>constructors: IOResult can normally be constructed directly from T or <a class="el" href="classmio_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a>. If T is convertible to an error code (e.g. T = int), these constructors are disabled. There are constructors IOResult(Tag&lt;T&gt;{}, t) and IOResult(Tag&lt;IOStatus&gt;{}, e) that always work.</li>
</ul>
<p>Inspect the result with:</p><ul>
<li><code>operator bool()</code>: true if result represents success.</li>
<li><code>value()</code>: returns a reference to the value.</li>
<li><code>error()</code>: returns a reference to the error. <code>value()</code>/<code>error()</code> assert (terminate in debug mode) if the result is not succesful/not an error.</li>
</ul>
<p>When nesting functions that return IOResult, it is also possible to unpack the value and forward errors using the macro BOOST_OUTCOME_TRY. The statement <code>BOOST_OUTCOME_TRY(x, try_get_x());</code> is equivalent to the statements </p><div class="fragment"><div class="line"><span class="keyword">auto</span> result = try_get_x();</div>
<div class="line"><span class="keywordflow">if</span> (!result) {</div>
<div class="line">  <span class="keywordflow">return</span> result.as_failure();</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span>&amp;&amp; x = result.value();</div>
</div><!-- fragment --><p> This way, code the branches that are added for error handling are not visible in your code, the logic looks completely linear, e.g.: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> use_int(<span class="keywordtype">int</span> i);</div>
<div class="line">IOResult&lt;void&gt; parse_and_use_int(<span class="keyword">const</span> std::string&amp; s)</div>
<div class="line">{</div>
<div class="line">  BOOST_OUTCOME_TRY(i, parse_int(s));</div>
<div class="line">  use_int(i);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespacemio.html#a80d7fd30c9669e05b537b2caedd82bb8">success</a>();</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemio_html_a80d7fd30c9669e05b537b2caedd82bb8"><div class="ttname"><a href="namespacemio.html#a80d7fd30c9669e05b537b2caedd82bb8">mio::success</a></div><div class="ttdeci">auto success()</div><div class="ttdoc">Create an object that is implicitly convertible to a succesful IOResult&lt;void&gt;.</div><div class="ttdef"><b>Definition:</b> io.h:352</div></div>
</div><!-- fragment --><p> The variable name can be omitted for operations that return IOResult&lt;void&gt;.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.boost.org/doc/libs/1_75_0/libs/outcome/doc/html/index.html">https://www.boost.org/doc/libs/1_75_0/libs/outcome/doc/html/index.html</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">the</td><td>type produced by an opertion that can fail. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affa0f99f4573e98460b38e88d9c107ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa0f99f4573e98460b38e88d9c107ba">&#9670;&nbsp;</a></span>is_compartment_model</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#affa0f99f4573e98460b38e88d9c107ba">mio::is_compartment_model</a> = typedef std::integral_constant&lt;bool, (<a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespacemio.html#a27dab8db023c553df90eb71275843f41">eval_right_hand_side_expr_t</a>, M&gt;::value &amp;&amp; <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespacemio.html#a861b27ba4067e505fdd45dec8087c169">get_initial_values_expr_t</a>, M&gt;::value)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template meta function to check if a type is a valid compartment model. </p>
<p>Defines a static constant of name <code>value</code>. The constant <code>value</code> will be equal to true if M is a valid compartment model type. Otherwise, <code>value</code> will be equal to false. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sim</td><td>a type that may or may not be a compartment model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fadf09764a83cd8c447f71052cd5d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fadf09764a83cd8c447f71052cd5d3c">&#9670;&nbsp;</a></span>is_compartment_model_simulation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a6fadf09764a83cd8c447f71052cd5d3c">mio::is_compartment_model_simulation</a> = typedef std::integral_constant&lt;bool, (<a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespacemio.html#af15ba49097f82eae310c5ed3d21a1b4b">advance_expr_t</a>, Sim&gt;::value &amp;&amp; <a class="el" href="namespacemio.html#affa0f99f4573e98460b38e88d9c107ba">is_compartment_model</a>&lt;typename Sim::Model&gt;::value)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template meta function to check if a type is a compartment model simulation. </p>
<p>Defines a static constant of name <code>value</code>. The constant <code>value</code> will be equal to true if Sim is a valid compartment simulation type. Otherwise, <code>value</code> will be equal to false. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sim</td><td>a type that may or may not be a compartment model simulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0752d0ad90c7c7789098b08021da4418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0752d0ad90c7c7789098b08021da4418">&#9670;&nbsp;</a></span>is_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a0752d0ad90c7c7789098b08021da4418">mio::is_container</a> = typedef <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespacemio_1_1details.html#aa2c4bf335b2dc1bff2495bf91e60e182">details::compare_iterators_t</a>, C&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is std::true_type if C is a STL compatible container. </p>
<p>Is std::false_type otherwise. See <a href="https://en.cppreference.com/w/cpp/named_req/Container">https://en.cppreference.com/w/cpp/named_req/Container</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>any type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a13de5a1cf9acb4db85042f9bc948ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a13de5a1cf9acb4db85042f9bc948ea">&#9670;&nbsp;</a></span>is_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a6a13de5a1cf9acb4db85042f9bc948ea">mio::is_iterator</a> = typedef <a class="el" href="structmio_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespacemio.html#a2f0a87714e50d80a23c07a795e1ac104">is_iterator_expr_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f0a87714e50d80a23c07a795e1ac104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0a87714e50d80a23c07a795e1ac104">&#9670;&nbsp;</a></span>is_iterator_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a2f0a87714e50d80a23c07a795e1ac104">mio::is_iterator_expr_t</a> = typedef typename std::iterator_traits&lt;T&gt;::iterator_category</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>meta function to check type T for beeing an iterator </p>

</div>
</div>
<a id="a36c063374af53e3976102aac4e24d676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c063374af53e3976102aac4e24d676">&#9670;&nbsp;</a></span>is_matrix_expression</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a36c063374af53e3976102aac4e24d676">mio::is_matrix_expression</a> = typedef std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template utility. </p>
<p>Defines value = true if M is an Eigen matrix expression. Defines value = false, otherwise. </p>

</div>
</div>
<a id="a8c0df224333a70c37fba34e10571431e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0df224333a70c37fba34e10571431e">&#9670;&nbsp;</a></span>is_no_default_init_tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a8c0df224333a70c37fba34e10571431e">mio::is_no_default_init_tag</a> = typedef std::is_same&lt;<a class="el" href="structmio_1_1NoDefaultInit.html">NoDefaultInit</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59bd2141b31d1f93df3d2274c999983b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bd2141b31d1f93df3d2274c999983b">&#9670;&nbsp;</a></span>MigrationCoefficientGroup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a59bd2141b31d1f93df3d2274c999983b">mio::MigrationCoefficientGroup</a> = typedef <a class="el" href="classmio_1_1DampingMatrixExpressionGroup.html">DampingMatrixExpressionGroup</a>&lt;<a class="el" href="namespacemio.html#abad9dfcf20607d4e66b7ad62ed250972">MigrationCoefficients</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sum of time dependent migration coefficients. </p>
<p>differentiate between sources of migration. </p>

</div>
</div>
<a id="abad9dfcf20607d4e66b7ad62ed250972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad9dfcf20607d4e66b7ad62ed250972">&#9670;&nbsp;</a></span>MigrationCoefficients</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmio_1_1DampingMatrixExpression.html">DampingMatrixExpression</a>&lt; <a class="el" href="namespacemio.html#a70fa1b55f14e56241f910c68e9ff75bc">VectorDampings</a> &gt; <a class="el" href="namespacemio.html#abad9dfcf20607d4e66b7ad62ed250972">mio::MigrationCoefficients</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>time dependent migration coefficients. </p>
<p>status and age dependent migration coefficients. </p>

</div>
</div>
<a id="a4546611409ee1989557a481c14b351cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4546611409ee1989557a481c14b351cc">&#9670;&nbsp;</a></span>not_copyable_if</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Cond&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a4546611409ee1989557a481c14b351cc">mio::not_copyable_if</a> = typedef std::conditional&lt;Cond, <a class="el" href="structmio_1_1details_1_1NoCopy.html">details::NoCopy</a>, <a class="el" href="structmio_1_1details_1_1Empty.html">details::Empty</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a type that is not copy constructible or assignable if the specified condition is true. </p>
<p>Otherwise, defines a type that is copyable. In both cases, the type will be trivially moveable and constructible. To be used as a base type to make a class conditionally copyable. Can be used to e.g. ensure that std::is_copy_constructible and std::is_copy_assignable is true only if the type can actually be copied (Note: this is not true for some STL containers, e.g., std::vector). </p>

</div>
</div>
<a id="a09eb65dfcf1a9314a36702c9481d8945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09eb65dfcf1a9314a36702c9481d8945">&#9670;&nbsp;</a></span>not_copyable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Cond&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a09eb65dfcf1a9314a36702c9481d8945">mio::not_copyable_if_t</a> = typedef typename <a class="el" href="namespacemio.html#a4546611409ee1989557a481c14b351cc">not_copyable_if</a>&lt;Cond&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>equivalent to not_copyable_if&lt;Cond&gt;::type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemio.html#a4546611409ee1989557a481c14b351cc" title="Defines a type that is not copy constructible or assignable if the specified condition is true.">not_copyable_if</a> </dd></dl>

</div>
</div>
<a id="a0c09d69095773d82728cea5345a40008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c09d69095773d82728cea5345a40008">&#9670;&nbsp;</a></span>ostream_op_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a0c09d69095773d82728cea5345a40008">mio::ostream_op_expr_t</a> = typedef decltype(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>meta function to check type T for an existing stream output operator "&lt;&lt;" </p>

</div>
</div>
<a id="a2bad6be33a5ea18476382e11a8f0f035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bad6be33a5ea18476382e11a8f0f035">&#9670;&nbsp;</a></span>ParameterDistributionVisitor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a2bad6be33a5ea18476382e11a8f0f035">mio::ParameterDistributionVisitor</a> = typedef <a class="el" href="structmio_1_1Visitor.html">Visitor</a>&lt;class <a class="el" href="classmio_1_1ParameterDistributionNormal.html">ParameterDistributionNormal</a>, class <a class="el" href="classmio_1_1ParameterDistributionUniform.html">ParameterDistributionUniform</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a visitor class to visit all Parameter Distribution objects. </p>
<p>More information to the visitor pattern is here: <a href="https://en.wikipedia.org/wiki/Visitor_pattern">https://en.wikipedia.org/wiki/Visitor_pattern</a> </p>

</div>
</div>
<a id="a2819b17099ccd2f065a0434b08e0f568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2819b17099ccd2f065a0434b08e0f568">&#9670;&nbsp;</a></span>ParameterTag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, class ParamSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a2819b17099ccd2f065a0434b08e0f568">mio::ParameterTag</a> = typedef <a class="el" href="structmio_1_1details_1_1ParameterTag.html">details::ParameterTag</a>&lt;I, ParamSet&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the the tag of the I-th parameter in a set </p>

</div>
</div>
<a id="a4f6887a5640de1b7f7cc6fafd0f46d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6887a5640de1b7f7cc6fafd0f46d15">&#9670;&nbsp;</a></span>ParameterTagT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, class ParamSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a4f6887a5640de1b7f7cc6fafd0f46d15">mio::ParameterTagT</a> = typedef typename <a class="el" href="namespacemio.html#a2819b17099ccd2f065a0434b08e0f568">ParameterTag</a>&lt;I, ParamSet&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1c9f969c0a8d114d1cfdff970cc99f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c9f969c0a8d114d1cfdff970cc99f9">&#9670;&nbsp;</a></span>serialize_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#af1c9f969c0a8d114d1cfdff970cc99f9">mio::serialize_t</a> = typedef decltype(std::declval&lt;T&gt;().<a class="el" href="namespacemio.html#a27a24b9e6cb629e04e9613446f07d6ba">serialize</a>(std::declval&lt;IOContext&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a037bdec009fea22e8426a48c1341b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a037bdec009fea22e8426a48c1341b8">&#9670;&nbsp;</a></span>SquareDamping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a4a037bdec009fea22e8426a48c1341b8">mio::SquareDamping</a> = typedef <a class="el" href="classmio_1_1Damping.html">Damping</a>&lt;<a class="el" href="classmio_1_1SquareMatrixShape.html">SquareMatrixShape</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>aliases for common damping specializations. </p>

</div>
</div>
<a id="a56cceedcb6dc114cc6992f13e163d7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cceedcb6dc114cc6992f13e163d7bb">&#9670;&nbsp;</a></span>SquareDampings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a56cceedcb6dc114cc6992f13e163d7bb">mio::SquareDampings</a> = typedef <a class="el" href="classmio_1_1Dampings.html">Dampings</a>&lt;<a class="el" href="namespacemio.html#a4a037bdec009fea22e8426a48c1341b8">SquareDamping</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f858e287c3935240954cf75cf53cfeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f858e287c3935240954cf75cf53cfeb">&#9670;&nbsp;</a></span>Tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">mio::Tag</a> = typedef boost::outcome_v2::in_place_type_t&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type that is used for overload resolution. </p>
<p>Use as dummy arguments to resolve overloads that would otherwise only differ by return type and don't have any other arguments that allow resolution. e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> foo(Tag&lt;int&gt;);</div>
<div class="line"><span class="keywordtype">double</span> foo(Tag&lt;double&gt;);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9114c7ed6467f9e2babbe5c9a2c03747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9114c7ed6467f9e2babbe5c9a2c03747">&#9670;&nbsp;</a></span>test_commuters_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a9114c7ed6467f9e2babbe5c9a2c03747">mio::test_commuters_expr_t</a> = typedef decltype(<a class="el" href="namespacemio.html#adb526164db4b433fe9e65133f20edd3d">test_commuters</a>( std::declval&lt;Sim&amp;&gt;(), std::declval&lt;Eigen::Ref&lt;const Eigen::VectorXd&gt;&amp;&gt;(), std::declval&lt;double&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>detect a get_migration_factors function for the Model type. </p>

</div>
</div>
<a id="af8c047ef17f8a7233b7e2a26e5ac3d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c047ef17f8a7233b7e2a26e5ac3d55">&#9670;&nbsp;</a></span>UniformDistribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#af8c047ef17f8a7233b7e2a26e5ac3d55">mio::UniformDistribution</a> = typedef <a class="el" href="classmio_1_1DistributionAdapter.html">DistributionAdapter</a>&lt;std::uniform_real_distribution&lt;Real&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adapted uniform_real_distribution. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmio_1_1DistributionAdapter.html" title="adapter for a random number distribution.">DistributionAdapter</a> </dd></dl>

</div>
</div>
<a id="a5edf6ec7616fca58178f25f339d25042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5edf6ec7616fca58178f25f339d25042">&#9670;&nbsp;</a></span>UniformIntDistribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a5edf6ec7616fca58178f25f339d25042">mio::UniformIntDistribution</a> = typedef <a class="el" href="classmio_1_1DistributionAdapter.html">DistributionAdapter</a>&lt;std::uniform_int_distribution&lt;Int&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adapted std::uniform_int_distribution. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmio_1_1DistributionAdapter.html" title="adapter for a random number distribution.">DistributionAdapter</a> </dd></dl>

</div>
</div>
<a id="a852855378d297141c058aa4d561b90e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852855378d297141c058aa4d561b90e9">&#9670;&nbsp;</a></span>VectorDamping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a852855378d297141c058aa4d561b90e9">mio::VectorDamping</a> = typedef <a class="el" href="classmio_1_1Damping.html">Damping</a>&lt;<a class="el" href="classmio_1_1ColumnVectorShape.html">ColumnVectorShape</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70fa1b55f14e56241f910c68e9ff75bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fa1b55f14e56241f910c68e9ff75bc">&#9670;&nbsp;</a></span>VectorDampings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#a70fa1b55f14e56241f910c68e9ff75bc">mio::VectorDampings</a> = typedef <a class="el" href="classmio_1_1Dampings.html">Dampings</a>&lt;<a class="el" href="namespacemio.html#a852855378d297141c058aa4d561b90e9">VectorDamping</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea7d5d010d42e770f94cd4e35c0bde71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7d5d010d42e770f94cd4e35c0bde71">&#9670;&nbsp;</a></span>VisitableParameterDistribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#aea7d5d010d42e770f94cd4e35c0bde71">mio::VisitableParameterDistribution</a> = typedef <a class="el" href="structmio_1_1Visitable.html">Visitable</a>&lt;Derived, class <a class="el" href="classmio_1_1ParameterDistribution.html">ParameterDistribution</a>, <a class="el" href="namespacemio.html#a2bad6be33a5ea18476382e11a8f0f035">ParameterDistributionVisitor</a>, <a class="el" href="namespacemio.html#ad8b64973f63b24b787e11ddbbb5f8dc3">ConstParameterDistributionVisitor</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af11f796ce6022b2a47e39adc29c89fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11f796ce6022b2a47e39adc29c89fcb">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemio.html#af11f796ce6022b2a47e39adc29c89fcb">mio::void_t</a> = typedef typename <a class="el" href="structmio_1_1details_1_1make__void.html">details::make_void</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>utility for meta programming that produces void for any valid type. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac653dd1d4b96e115aa994b6a627fac2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac653dd1d4b96e115aa994b6a627fac2a">&#9670;&nbsp;</a></span>IOFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemio.html#ac653dd1d4b96e115aa994b6a627fac2a">mio::IOFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flags to determine the behavior of the serialization process. </p>
<p>Objects must be deseralized with the same set of flags as they were serialized. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac653dd1d4b96e115aa994b6a627fac2aa3d42ed7bd1f2ca56e839ce87b785c3c8"></a>IOF_None&#160;</td><td class="fielddoc"><p>default behavior. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac653dd1d4b96e115aa994b6a627fac2aa404382b13f293f4a6f83c9dcb6be559f"></a>IOF_OmitDistributions&#160;</td><td class="fielddoc"><p>Don't serialize distributions for types that contain both a specific value and a distribution from which new values can be sampled, e.g. </p>
<p><a class="el" href="classmio_1_1UncertainValue.html" title="The UncertainValue class consists of a scalar value and a Distribution object.">UncertainValue</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac653dd1d4b96e115aa994b6a627fac2aab2c1a59881d6eff77aec6971ff2b1d21"></a>IOF_OmitValues&#160;</td><td class="fielddoc"><p>Don't serialize the current value for types that contain both a specific value and a distribution from which new values can be sampled, e.g., <a class="el" href="classmio_1_1UncertainValue.html" title="The UncertainValue class consists of a scalar value and a Distribution object.">UncertainValue</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac653dd1d4b96e115aa994b6a627fac2aac1c4426ed4cd40b1dbe5876d11c0be30"></a>IOF_IncludeTypeInfo&#160;</td><td class="fielddoc"><p>Include type info in the serialization. </p>
<p>Can Increase file size a lot, mostly for debugging. </p>
</td></tr>
</table>

</div>
</div>
<a id="a67881790c6dfd8c058d27e5f1fe24220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67881790c6dfd8c058d27e5f1fe24220">&#9670;&nbsp;</a></span>LogLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220">mio::LogLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a67881790c6dfd8c058d27e5f1fe24220a04a75036e9d520bb983c5ed03b8d0182"></a>trace&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67881790c6dfd8c058d27e5f1fe24220aad42f6697b035b7580e4fef93be20b4d"></a>debug&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67881790c6dfd8c058d27e5f1fe24220acaf9b6b99962bf5c2264824231d7a40c"></a>info&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67881790c6dfd8c058d27e5f1fe24220a1ea4c3ab05ee0c6d4de30740443769cb"></a>warn&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67881790c6dfd8c058d27e5f1fe24220a56bd7107802ebe56c6918992f0608ec6"></a>err&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67881790c6dfd8c058d27e5f1fe24220a7e85bcb66fb9a809d5ab4f62a8b8bea8"></a>critical&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67881790c6dfd8c058d27e5f1fe24220a3262d48df5d75e3452f0f16b313b7808"></a>off&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a2799d348d433018d5b183d75bfbdd699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2799d348d433018d5b183d75bfbdd699">&#9670;&nbsp;</a></span>StatusCode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699">mio::StatusCode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>code to indicate the result of an operation. </p>
<p>convertible to std::error_code. see <a href="https://www.boost.org/doc/libs/1_75_0/libs/outcome/doc/html/motivation/plug_error_code.html">https://www.boost.org/doc/libs/1_75_0/libs/outcome/doc/html/motivation/plug_error_code.html</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2799d348d433018d5b183d75bfbdd699ae0aa021e21dddbd6d8cecec71e9cf564"></a>OK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2799d348d433018d5b183d75bfbdd699abfaef30f1c8011c5cefa38ae470fb7aa"></a>UnknownError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2799d348d433018d5b183d75bfbdd699a365b2699d38b61ef4b4c8a1066c8468f"></a>OutOfRange&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2799d348d433018d5b183d75bfbdd699a223e81e8afa42c41346a6696560ecc7b"></a>InvalidValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2799d348d433018d5b183d75bfbdd699ade9a4832789ef70d5f9bee2a83345e8a"></a>InvalidFileFormat&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2799d348d433018d5b183d75bfbdd699aa645e4cfc8d16be330607ad52aec5f98"></a>KeyNotFound&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2799d348d433018d5b183d75bfbdd699ac85f85f7c13ed006eed130ec183aa810"></a>InvalidType&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2799d348d433018d5b183d75bfbdd699a2767828026039e8ba7b38973cbb701f2"></a>FileNotFound&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aee4a248956bde1057171ea901504e5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4a248956bde1057171ea901504e5e3">&#9670;&nbsp;</a></span>abs_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mio::abs_max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maximum absolute value of two numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first number </td></tr>
    <tr><td class="paramname">v2</td><td>second number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum absolute value between v1 and v2 </dd></dl>

</div>
</div>
<a id="a3cd34c233549e8b0e086c67fd82809d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd34c233549e8b0e086c67fd82809d3">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class F , class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio_1_1details.html#a98c0eea24e7bbb725e78e8c7c6b22e8a">details::ApplyResultT</a>&lt;F, T...&gt; mio::apply </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; T &gt; &amp;...&#160;</td>
          <td class="paramname"><em>rs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a function with zero or more unpacked IOResults as arguments. </p>
<p>Returns an IOResult that contains the result of <code>f(rs.value()...)</code> if all IOResults <code>rs</code> contain a value. If any IOResult contains an error, that error is returned instead. The function f may return an object of any type U. It can also return IOResult<u> (e.g. to validate the values contained in the arguments). In either case, apply returns IOResult<u> and never any nested IOResult&lt;IOResult<u>&gt;. If apply returns an error, it is also stored in the given IO context so that the context is informed of e.g. validation errors that cannot be checked simply from the types and the format of the file. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type with a set_error(const IOStatus&amp;) member function. </td></tr>
    <tr><td class="paramname">F</td><td>a type that has a function call operator with signature either <code>U F(T&amp;&amp;...)</code> or <code>IOResult&lt;U&gt; F(T&amp;&amp;...)</code> for any <code>U</code>. </td></tr>
    <tr><td class="paramname">T</td><td>zero ore more types of values contained in the IOResult arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IOContext that is notified of errors. </td></tr>
    <tr><td class="paramname">f</td><td>the function that is called with the values contained in <code>rs</code> as arguments. </td></tr>
    <tr><td class="paramname">rs</td><td>zero or more IOResults from previous operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of f(rs.value()...) if successful, the first error encountered otherwise. </dd></dl>
<p></u></u></u></p>

</div>
</div>
<a id="a24d87651a07c02cb6bd9c27a6518069e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d87651a07c02cb6bd9c27a6518069e">&#9670;&nbsp;</a></span>apply_dampings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DampingExpression , class DampingSamplings , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::apply_dampings </td>
          <td>(</td>
          <td class="paramtype">DampingExpression &amp;&#160;</td>
          <td class="paramname"><em>damping_expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DampingSamplings &amp;&#160;</td>
          <td class="paramname"><em>dampings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>make_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add sampled dampings to a damping expression. </p>
<p>does not draw new random value, just adds dampings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">damping_expression</td><td>e.g. contact matrix group. </td></tr>
    <tr><td class="paramname">dampings</td><td>sampled dampings. </td></tr>
    <tr><td class="paramname">make_mask</td><td>functor that creates a matrix from damping value weighted by group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70bce3d20b307a99caf57331c0250537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bce3d20b307a99caf57331c0250537">&#9670;&nbsp;</a></span>apply_migration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::apply_migration </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>migrationEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge functor for migration simulation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmio_1_1MigrationEdge.html#a210e9760d358e9b84ecda8f04e5881b3" title="compute migration from node_from to node_to.">MigrationEdge::apply_migration</a> </dd></dl>

</div>
</div>
<a id="a456698e86179ed8ee48f44e3d9d8d85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456698e86179ed8ee48f44e3d9d8d85c">&#9670;&nbsp;</a></span>apply_migration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim , class StochasticEdge &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::apply_migration </td>
          <td>(</td>
          <td class="paramtype">StochasticEdge &amp;&#160;</td>
          <td class="paramname"><em>migrationEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge functor for migration simulation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmio_1_1MigrationEdgeStochastic.html#ae527b7c26e6e26605a7bb92ba999ef4f" title="compute migration from node_from to node_to for a given event">MigrationEdgeStochastic::apply_migration</a> </dd></dl>

</div>
</div>
<a id="ac64767b14d2fc4a7495e8401fb171bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64767b14d2fc4a7495e8401fb171bcd">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;::value, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, true&gt; &gt; mio::begin </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a const iterator to first element of the matrix m. </p>

</div>
</div>
<a id="aa6c974748a742fac0093de2634750791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c974748a742fac0093de2634750791">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacemio.html#a5e1169fe9e5d36e1c3a2bf558a874049">conjunction_v</a>&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;, <a class="el" href="namespacemio_1_1details.html#aa2d4aa6db3f379aa09e21f3378bd85d2">details::IsElementReference</a>&lt;M&gt; &gt;, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, false&gt; &gt; mio::begin </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a non-const iterator to first element of the matrix m. </p>
<p>only enabled if the matrix is evaluated in memory, i.e. elements can be modified. </p>

</div>
</div>
<a id="ac756601e49cde978ae849e736f7ffd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac756601e49cde978ae849e736f7ffd5e">&#9670;&nbsp;</a></span>calculate_migration_returns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim , class  = std::enable_if_t&lt;is_compartment_model_simulation&lt;Sim&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::calculate_migration_returns </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;::Vector &gt;&#160;</td>
          <td class="paramname"><em>migrated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sim &amp;&#160;</td>
          <td class="paramname"><em>sim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;::Vector &gt;&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adjust number of migrated people when they return according to the model. </p>
<p>E.g. during the time in the other node, some people who left as susceptible will return exposed. Implemented for general compartmentmodel simulations, overload for your custom model if necessary so that it can be found with argument-dependent lookup, i.e. in the same namespace as the model. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">migrated</td><td>number of people that migrated as input, number of people that return as output </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params</td><td>parameters of model in the node that the people migrated to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">total</td><td>total population in the node that the people migrated to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">t</td><td>time of migration </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dt</td><td>time between migration and return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a682d1d1100a18177c401a32cbcdb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a682d1d1100a18177c401a32cbcdb80">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;::value, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, true&gt; &gt; mio::cbegin </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a const iterator to first element of the matrix m. </p>

</div>
</div>
<a id="a28b97a27d22568b3ab044955ac3e6f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b97a27d22568b3ab044955ac3e6f3d">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;::value, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, true&gt; &gt; mio::cend </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a non-const end iterator for the matrix m. </p>

</div>
</div>
<a id="afd44eabeb55837aa5f3e2ecfa351f049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd44eabeb55837aa5f3e2ecfa351f049">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter , class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mio::contains </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if there is an element in this range that matches a predicate </p>

</div>
</div>
<a id="a31f25a359f1daa4e482fb58724bd9237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f25a359f1daa4e482fb58724bd9237">&#9670;&nbsp;</a></span>count_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; int &gt; mio::count_lines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts lines of txt file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of file which is counted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d3e99d87ecd03e78eef03c54a8e58d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3e99d87ecd03e78eef03c54a8e58d2">&#9670;&nbsp;</a></span>create_directory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; bool &gt; mio::create_directory </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>rel_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a directory in the file system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel_path</td><td>path of directory relative to current working directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the directory was created, false if it already exists, or any errors that occured. </dd></dl>

</div>
</div>
<a id="a075272e6cfaf25ad2292e4108c2309a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075272e6cfaf25ad2292e4108c2309a9">&#9670;&nbsp;</a></span>create_directory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; bool &gt; mio::create_directory </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>rel_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>abs_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a directory in the file system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel_path</td><td>path of directory relative to current working directory. </td></tr>
    <tr><td class="paramname">abs_path</td><td>Will contain the absolute path of the directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the directory was created, false if it already exists, or any errors that occured. </dd></dl>

</div>
</div>
<a id="adf154a6f66ef76f9a3fbb7424df9c31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf154a6f66ef76f9a3fbb7424df9c31d">&#9670;&nbsp;</a></span>create_graph_without_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodePropertyT , class EdgePropertyT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::create_graph_without_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; NodePropertyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an unconnected graph. </p>
<p>Can be used to save space on disk when writing parameters if the edges are not required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_properties</td><td>Vector of node properties of all nodes, e.g., parameters in each model node. </td></tr>
    <tr><td class="paramname">node_ids</td><td>Indices for the nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmio_1_1Graph.html" title="generic graph structure">Graph</a> with nodes only having no edges. </dd></dl>

</div>
</div>
<a id="ac2fcaac4322368f99802f6a206a93c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fcaac4322368f99802f6a206a93c92">&#9670;&nbsp;</a></span>DECL_TYPESAFE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mio::DECL_TYPESAFE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingLevel&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>integer damping level. </p>

</div>
</div>
<a id="a2b0876aea98f5bc41a0202c7b0c7fb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0876aea98f5bc41a0202c7b0c7fb53">&#9670;&nbsp;</a></span>DECL_TYPESAFE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mio::DECL_TYPESAFE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>integer damping type. </p>

</div>
</div>
<a id="a1eecf99ef3a231d628f968aeb2136865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eecf99ef3a231d628f968aeb2136865">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; T &gt; mio::deserialize </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores an object from the data stored in an IO context. </p>
<p>There must be provided for the type T either a free function <code>deserialize_internal(io, tag)</code> that can be found using argument dependent lookup (ADL) or a static member function <code>T::deserialize(io)</code>. The <code>deserialize_internal</code> function or <code>deserialize</code> member function retrieve the data needed to restore the object from the IO context. The context provides the data if it can and keeps track of errors. <code>deserialize_internal</code> overloads are already provided for many common types, e.g. STL containers or Eigen Matrices. <code>serialize</code> and <code>deserialize</code> are the main entry points into this IO framework, but there may be more convenient functions provided for specific IO contexts. These functions are not expected to use ADL, so should be called namespace qualified. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">T</td><td>any deserializable type, i.e., that has a <code>deserialize</code> member function or <code>deserialize_internal</code> overload </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>IO context that contains the data for an object of type T </td></tr>
    <tr><td class="paramname">tag</td><td>specifies the type to be restored from the data, for overload resolution only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the restored T if succesful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="a4883dd8d61080057dbdccf25181f5462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4883dd8d61080057dbdccf25181f5462">&#9670;&nbsp;</a></span>deserialize_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt;T&gt; mio::deserialize_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmio_1_1ByteStream.html">ByteStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; T &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize an object from binary format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td><a class="el" href="classmio_1_1ByteStream.html" title="In-memory stream of bytes.">ByteStream</a> that contains the bytes that represent the object. </td></tr>
    <tr><td class="paramname">tag</td><td>Tag that carries the type of the object to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The deserialized object if succesful, an error otherwise. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the object to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1da91fbacc2d6ed8cc4e106d7016e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1da91fbacc2d6ed8cc4e106d7016e14">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class Container , std::enable_if_t&lt;(is_container&lt; Container &gt;::value &amp;&amp;!is_expression_valid&lt; serialize_t, IOContext, Container &gt;::value), void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt;Container&gt; mio::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; Container &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize an STL compatible container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">Container</td><td>the container type to be deserialized. A container is anything with begin and end iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">tag</td><td>defines the type of the container to be serialized for overload resolution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>restored container if successful, error otherwise. </dd></dl>

</div>
</div>
<a id="a1525dc162e36390f91c4e30c4b50d5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1525dc162e36390f91c4e30c4b50d5cc">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class E , std::enable_if_t&lt; std::is_enum&lt; E &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt;E&gt; mio::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; E &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize an enum value from its underlying type. </p>
<p>It is impossible to validate the range of the enum type, validate after if necessary. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">E</td><td>an enum type to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context </td></tr>
    <tr><td class="paramname">tag</td><td>defines the type of the enum to be deserialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an enum value if succesful, an error otherwise. </dd></dl>

</div>
</div>
<a id="a210ceb31e6e751b667b64fe06389b6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210ceb31e6e751b667b64fe06389b6a5">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class M , std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt;M&gt; mio::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; M &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize an Eigen matrix. </p>
<p>It is possible to serialize an unevaluated expression, e.g. Eigen::MatrixXd::Constant(r, c, v). But it is (at least currently) not possible to deserialize it. Only matrices that own their memory can be deserialized. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">M</td><td>the type of Eigen matrix expression to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">tag</td><td>defines the type of the matrix to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed78855a4ca0601a2661465658052c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed78855a4ca0601a2661465658052c49">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt;std::shared_ptr&lt;<a class="el" href="classmio_1_1ParameterDistribution.html">ParameterDistribution</a>&gt; &gt; mio::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; std::shared_ptr&lt; <a class="el" href="classmio_1_1ParameterDistribution.html">ParameterDistribution</a> &gt;&gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize a parameter distribution as a shared_ptr. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemio.html#a1eecf99ef3a231d628f968aeb2136865" title="Restores an object from the data stored in an IO context.">mio::deserialize</a> </dd></dl>

</div>
</div>
<a id="a3bee6e76e87298ab8dc95c7c97591f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bee6e76e87298ab8dc95c7c97591f6f">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T , std::enable_if_t&lt; has_deserialize&lt; IOContext, T &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt;T&gt; mio::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; T &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize an object that has a deserialize(io) static member function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">T</td><td>the type of the object to be deserialized. Must have a serialize member function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an io context. </td></tr>
    <tr><td class="paramname">tag</td><td>defines the type of the object for overload resolution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the restored object if succesful, an error otherwise. </dd></dl>

</div>
</div>
<a id="a00cf52f73f21f24b421264732496fe81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cf52f73f21f24b421264732496fe81">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class Tup , class  = std::enable_if_t&lt;is_expression_valid&lt;details::tuple_size_value_t, Tup&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt;Tup&gt; mio::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a>&lt; Tup &gt;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize a tuple-like object, e.g. </p>
<p>std::tuple or std::pair. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">Tup</td><td>the tuple-like type to be deserialized, i.e. anything that supports tuple_size and tuple_element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">tag</td><td>define the type of the object to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a restored tuple </dd></dl>

</div>
</div>
<a id="a53006511360e7600ccee2ca9732a3d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53006511360e7600ccee2ca9732a3d72">&#9670;&nbsp;</a></span>dynamic_unique_ptr_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;U&gt; mio::dynamic_unique_ptr_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>base_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts a unique_ptr&lt;T&gt; to unique_ptr<u>. </u></p>
<p>behavior is similar to normal dynamic_cast except if the conversion is successful, the original unique_ptr&lt;T&gt; is now in a moved-from state and ownership of the object has been transferred to the returned unique_ptr<u>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_ptr</td><td>ptr to object to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted unique_ptr if object can be cast to U, default unique_ptr otherwise </dd></dl>
<p></u></p>

</div>
</div>
<a id="ad05d756edaa40a44169157a01a25162b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05d756edaa40a44169157a01a25162b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;::value, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, true&gt; &gt; mio::end </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a const end iterator for the matrix m. </p>

</div>
</div>
<a id="a81e603f62801572c7afdf910bc057681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e603f62801572c7afdf910bc057681">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacemio.html#a5e1169fe9e5d36e1c3a2bf558a874049">conjunction_v</a>&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;, <a class="el" href="namespacemio_1_1details.html#aa2d4aa6db3f379aa09e21f3378bd85d2">details::IsElementReference</a>&lt;M&gt; &gt;, <a class="el" href="classmio_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, false&gt; &gt; mio::end </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a non-const end iterator for the matrix m. </p>

</div>
</div>
<a id="a88dd731de720e6138565538e26b0f01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88dd731de720e6138565538e26b0f01b">&#9670;&nbsp;</a></span>ensemble_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt; mio::ensemble_mean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ensemble_results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes mean of each compartment, node, and time point over all runs input must be uniform as returned by interpolated_ensemble_result: same number of nodes, same time points and elements. </p>
<dl class="section see"><dt>See also</dt><dd>interpolated_ensemble_result </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ensemble_results</td><td>uniform results of multiple simulation runs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mean of the results over all runs </dd></dl>

</div>
</div>
<a id="a66e6c3ccb05b51b0a86cec52f57d49a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e6c3ccb05b51b0a86cec52f57d49a1">&#9670;&nbsp;</a></span>ensemble_percentile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt; mio::ensemble_percentile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ensemble_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the p percentile of the result for each compartment, node, and time point. </p>
<p>Produces for each compartment the value that that is bigger than approximately a p-th share of the values of this compartment over all runs. input must be uniform as returned by interpolated_ensemble_result: same number of nodes, same time points and elements. </p><dl class="section see"><dt>See also</dt><dd>interpolated_ensemble_result </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ensemble_result</td><td>uniform results of multiple simulation runs </td></tr>
    <tr><td class="paramname">p</td><td>percentile value in open interval (0, 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>p percentile of the results over all runs </dd></dl>

</div>
</div>
<a id="aebf8e2a8ccea82f3bbd91c3d479d1094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf8e2a8ccea82f3bbd91c3d479d1094">&#9670;&nbsp;</a></span>evolve_model()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::evolve_model </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge functor for migration simulation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmio_1_1SimulationNode.html#a9a8c41cc352e8e1122fe80304768f951">SimulationNode::evolve</a> </dd></dl>

</div>
</div>
<a id="a23604adfeac7ebc8418d741959e80906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23604adfeac7ebc8418d741959e80906">&#9670;&nbsp;</a></span>failure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto mio::failure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmio_1_1IOStatus.html">IOStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object that is implicitly convertible to an error IOResult&lt;T&gt;. </p>
<p>Use <code>return failure(s)</code> to conveniently return an error from a function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the status that contains the error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0bf8987d98c937bf01f7ba27b5a2b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bf8987d98c937bf01f7ba27b5a2b1a">&#9670;&nbsp;</a></span>failure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto mio::failure </td>
          <td>(</td>
          <td class="paramtype">std::error_code&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object that is implicitly convertible to an error IOResult&lt;T&gt;. </p>
<p>Use <code>return failure(c, msg)</code> to conveniently return an error from a function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>an error code. </td></tr>
    <tr><td class="paramname">msg</td><td>a string that contains more information about the error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa59f4cb5fc6b5dd160a8e1a9b049da85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59f4cb5fc6b5dd160a8e1a9b049da85">&#9670;&nbsp;</a></span>file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mio::file_exists </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>rel_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>abs_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a file exists. </p>
<p>Also computes the absolute path of the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rel_path</td><td>relative path to the file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">abs_path</td><td>absolute path, computed by the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file exists. </dd></dl>

</div>
</div>
<a id="a38394b93b07245eb4a96b20810547004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38394b93b07245eb4a96b20810547004">&#9670;&nbsp;</a></span>find_value_reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TS , class FP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(std::declval&lt;TS&gt;().rend()) mio::find_value_reverse </td>
          <td>(</td>
          <td class="paramtype">TS &amp;&amp;&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FP&#160;</td>
          <td class="paramname"><em>t_search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FP&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FP&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the value in the time series at time t_search starting from the end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ts</td><td><a class="el" href="classmio_1_1TimeSeries.html" title="stores vectors of values at time points (or some other abstract variable) the value at each time poin...">TimeSeries</a> to seach </td></tr>
    <tr><td class="paramname">t_search</td><td>a time point </td></tr>
    <tr><td class="paramname">abs_tol</td><td>absolute floating point tolerance for equality of time values </td></tr>
    <tr><td class="paramname">rel_tol</td><td>relative floating point tolerance for equality of time values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmio_1_1TimeSeries.html#a949fc79fdef405312fb1331d10511e50">TimeSeries::reverse_iterator</a> that points to ts[t_search] or ts.rend() </dd></dl>

</div>
</div>
<a id="aa3c86fcbad351d59edddf6f8a113f338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c86fcbad351d59edddf6f8a113f338">&#9670;&nbsp;</a></span>flatten_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MultiIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t mio::flatten_index </td>
          <td>(</td>
          <td class="paramtype">MultiIndex const &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiIndex const &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flatten_index takes a set of indices into a mutlidemsional array and calculates the flat index </p>
<p>Given indices (i,j,k,...) of a tensor with dimensions (n,m,l,...), flatten_index calculates the index of the corresponding element if the elements are sorted sequentially in a row major fashion (that is right indices are incremented before left indices)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>a vector of indices of a hypothetical tensor </td></tr>
    <tr><td class="paramname">dimensions</td><td>a vector of the dimension sizes of each dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding flat index </dd></dl>

</div>
</div>
<a id="aa0a2754ccbfffaac53e9769bd3cc6012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a2754ccbfffaac53e9769bd3cc6012">&#9670;&nbsp;</a></span>floating_point_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mio::floating_point_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>std::numeric_limits&lt;T&gt;::min()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare two floating point values for equality with tolerances. </p>
<p>Use absolute tolerance for comparisons with zero or if you know the magnitude of the values. Otherwise use relative tolerance. If unsure, use both. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first floating point value </td></tr>
    <tr><td class="paramname">v2</td><td>second floating point value </td></tr>
    <tr><td class="paramname">abs_tol</td><td>maximum allowed absolute difference, default 0. </td></tr>
    <tr><td class="paramname">rel_tol</td><td>maximum allowed relative difference, default numeric_limits::min. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 is within the specified relative OR absolute tolerance of v2 <br  />
 </dd></dl>

</div>
</div>
<a id="ae39bcb0450014505388317998eac4382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39bcb0450014505388317998eac4382">&#9670;&nbsp;</a></span>floating_point_greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mio::floating_point_greater </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>std::numeric_limits&lt;T&gt;::min()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare two floating point values with tolerances. </p>
<p>v1 &gt; v2 if a) v1 not == v2 within tolerances AND b) v1 not &lt; v2. Use absolute tolerance for comparisons with zero or if you know the magnitude of the values. Use relative tolerance (or both) otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first floating point value </td></tr>
    <tr><td class="paramname">v2</td><td>second floating point value </td></tr>
    <tr><td class="paramname">abs_tol</td><td>maximum allowed absolute difference, default 0. </td></tr>
    <tr><td class="paramname">rel_tol</td><td>maximum allowed relative difference, default numeric_limits::min. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 is greater than v2 and not within absolute or relative tolerance of v2. </dd></dl>

</div>
</div>
<a id="a25921aa2ea732bff75b46b5b6732fd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25921aa2ea732bff75b46b5b6732fd0e">&#9670;&nbsp;</a></span>floating_point_greater_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mio::floating_point_greater_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>std::numeric_limits&lt;T&gt;::min()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare two floating point values with tolerances. </p>
<p>v1 &gt;= v2 if a) v1 &gt; v2 OR b) v1 == v2 within tolerances. Use absolute tolerance for comparisons with zero or if you know the magnitude of the values. Use relative tolerance (or both) otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first floating point value </td></tr>
    <tr><td class="paramname">v2</td><td>second floating point value </td></tr>
    <tr><td class="paramname">abs_tol</td><td>maximum allowed absolute difference, default 0. </td></tr>
    <tr><td class="paramname">rel_tol</td><td>maximum allowed relative difference, default numeric_limits::min. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 is greater than v2 or within absolute or relative tolerance of v2. </dd></dl>

</div>
</div>
<a id="a1f9bad77bdfbdd77c10acb268da42188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9bad77bdfbdd77c10acb268da42188">&#9670;&nbsp;</a></span>floating_point_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mio::floating_point_less </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>std::numeric_limits&lt;T&gt;::min()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare two floating point values with tolerances. </p>
<p>v1 &lt; v2 if a) v1 not == v2 within tolerances and b) v1 not &gt; v2. Use absolute tolerance for comparisons with zero or if you know the magnitude of the values. Use relative tolerance (or both) otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first floating point value </td></tr>
    <tr><td class="paramname">v2</td><td>second floating point value </td></tr>
    <tr><td class="paramname">abs_tol</td><td>maximum allowed absolute difference for equality, default 0. </td></tr>
    <tr><td class="paramname">rel_tol</td><td>maximum allowed relative difference for equality, default numeric_limits::min. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 is less than v2 and not within relative or absolute tolerance of v2. </dd></dl>

</div>
</div>
<a id="a77e09296ef9bcb3133b719e0356b1092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e09296ef9bcb3133b719e0356b1092">&#9670;&nbsp;</a></span>floating_point_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mio::floating_point_less_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>std::numeric_limits&lt;T&gt;::min()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare two floating point values with tolerances. </p>
<p>v1 &lt;= v2 if a) v1 &lt; v2 OR b) v1 == v2 within tolerances. Use absolute tolerance for comparisons with zero or if you know the magnitude of the values. Use relative tolerance (or both) otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first floating point value </td></tr>
    <tr><td class="paramname">v2</td><td>second floating point value </td></tr>
    <tr><td class="paramname">abs_tol</td><td>maximum allowed absolute difference, default 0. </td></tr>
    <tr><td class="paramname">rel_tol</td><td>maximum allowed relative difference, default numeric_limits::min. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 is less than v2 or within relative or absolute tolerances of v2. </dd></dl>

</div>
</div>
<a id="a8b4636578fa72f7895297605fe68d1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4636578fa72f7895297605fe68d1a8">&#9670;&nbsp;</a></span>foreach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... Tags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmio_1_1ParameterSet.html">ParameterSet</a>&lt; Tags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call f(p, t) for all parameters in a <a class="el" href="classmio_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> with p the value of the parameter t a default constructed parameter tag </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The function type of f </td></tr>
    <tr><td class="paramname">Tags</td><td>the parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the <a class="el" href="classmio_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> </td></tr>
    <tr><td class="paramname">f</td><td>The function to be called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e2e332916b581a92ab49fa06b25606a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2e332916b581a92ab49fa06b25606a">&#9670;&nbsp;</a></span>foreach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... Tags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmio_1_1ParameterSet.html">ParameterSet</a>&lt; Tags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39bb377d592d615e42466404fabe9c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bb377d592d615e42466404fabe9c88">&#9670;&nbsp;</a></span>foreach_tag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Params , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::foreach_tag </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call f(t) for all parameters in a <a class="el" href="classmio_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> with t a default constructed parameter tag </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>a <a class="el" href="classmio_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> </td></tr>
    <tr><td class="paramname">F</td><td>The function type of f </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bfe99028c36206c267431a3549f3c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfe99028c36206c267431a3549f3c6e">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::tuple_element&lt; I, std::tuple&lt; <a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags &gt;... &gt; &gt;::type &amp; mio::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5628c5c563026082e6d80065e86192ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5628c5c563026082e6d80065e86192ba">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmio_1_1Index.html">Index</a>&lt; <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a> &gt; &amp; mio::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa927253c961ab06ce52b147bc8449115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa927253c961ab06ce52b147bc8449115">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::tuple_element&lt; I, std::tuple&lt; <a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags &gt;... &gt; &gt;::type const  &amp; mio::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af78eb98cdade4f5eb661d0acd2f51620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78eb98cdade4f5eb661d0acd2f51620">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmio_1_1Index.html">Index</a>&lt; <a class="el" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">Tag</a> &gt; const  &amp; mio::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmio_1_1Index.html">Index</a>&lt; CategoryTags... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11d5ab01f91eb6076294d22fec9387e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d5ab01f91eb6076294d22fec9387e2">&#9670;&nbsp;</a></span>get_active_damping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DampingExpr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Ref&lt;const typename DampingExpr::Matrix&gt; mio::get_active_damping </td>
          <td>(</td>
          <td class="paramtype">const DampingExpr &amp;&#160;</td>
          <td class="paramname"><em>damping_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingLevel&#160;</td>
          <td class="paramname"><em>lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1SimulationTime.html">SimulationTime</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of the damping that matches the given type and level and that is active at the specified time. </p>
<p>If no damping is found, returns a zero matrix of the correct shape. Utility for implementation of dynamic NPIs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">damping_expr</td><td>some matrix expression that contains dampings, e.g. a <a class="el" href="classmio_1_1ContactMatrix.html" title="represents time dependent contact frequencies between groups.">ContactMatrix</a>. </td></tr>
    <tr><td class="paramname">lvl</td><td>damping level to match </td></tr>
    <tr><td class="paramname">type</td><td>damping type to match </td></tr>
    <tr><td class="paramname">time</td><td>time where the damping is active </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>matrix of damping coefficients if active damping is found. zero matrix otherwise. </dd></dl>

</div>
</div>
<a id="a25d08a85d7a7fb01a5ff6899c6003164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d08a85d7a7fb01a5ff6899c6003164">&#9670;&nbsp;</a></span>get_current_dir_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mio::get_current_dir_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current working directory name. </p>

</div>
</div>
<a id="a46e96aa6399be967e2261e9054d45fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e96aa6399be967e2261e9054d45fa3">&#9670;&nbsp;</a></span>get_damping_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DampingExpr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; mio::get_damping_indices </td>
          <td>(</td>
          <td class="paramtype">const DampingExpr &amp;&#160;</td>
          <td class="paramname"><em>damping_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingLevel&#160;</td>
          <td class="paramname"><em>lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1SimulationTime.html">SimulationTime</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1SimulationTime.html">SimulationTime</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of indices of specified dampings. </p>
<p>Returns the indices of dampings that match the given type and level and that become active in the specified time span (excluding the particular interval boundaries, begin and end). Utility for implementation of dynamic NPIs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">damping_expr</td><td>some matrix expression that contains dampings, e.g. a <a class="el" href="classmio_1_1ContactMatrix.html" title="represents time dependent contact frequencies between groups.">ContactMatrix</a>. </td></tr>
    <tr><td class="paramname">lvl</td><td>damping level to match </td></tr>
    <tr><td class="paramname">type</td><td>damping type to match </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the time span that contains the dampings </td></tr>
    <tr><td class="paramname">end</td><td>end of the time span that contains the dampings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of indices in range damping_expr.get_dampings() </dd></dl>

</div>
</div>
<a id="af05c44a9a8cdb809f88f9b7f0767ba48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05c44a9a8cdb809f88f9b7f0767ba48">&#9670;&nbsp;</a></span>get_day_in_year()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mio::get_day_in_year </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmio_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the day in year based on a given date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>date </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>day in year, starting January, 1st, with 1. </dd></dl>

</div>
</div>
<a id="a85ab6b99636fa04a3d21cb8d08fc4c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ab6b99636fa04a3d21cb8d08fc4c08">&#9670;&nbsp;</a></span>get_infections_relative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim , std::enable_if_t&lt;!is_expression_valid&lt; get_infections_relative_expr_t, Sim &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mio::get_infections_relative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the percantage of infected people of the total population in the node If dynamic NPIs are enabled, there needs to be an overload of get_infections_relative(model, y) for the Model type that can be found with argument-dependent lookup. </p>
<p>Ideally define get_infections_relative in the same namespace as the Model type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a node of a migration graph. </td></tr>
    <tr><td class="paramname">y</td><td>the current value of the simulation. </td></tr>
    <tr><td class="paramname">t</td><td>the current simulation time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab74f1d86f5a3421e7a971c22b50fd89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74f1d86f5a3421e7a971c22b50fd89c">&#9670;&nbsp;</a></span>get_migration_factors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim , std::enable_if_t&lt;!is_expression_valid&lt; get_migration_factors_expr_t, Sim &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::get_migration_factors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an additional migration factor. </p>
<p>The absolute migration for each compartment is computed by c_i * y_i * f_i, wher c_i is the coefficient set in <a class="el" href="classmio_1_1MigrationParameters.html" title="parameters that influence migration.">MigrationParameters</a>, y_i is the current compartment population, f_i is the factor returned by this function. This factor is optional, default 1.0. If you need to adjust migration in that way, overload get_migration_factors(model, t, y) for your Model type so that can be found with argument-dependent lookup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a node of a migration graph. </td></tr>
    <tr><td class="paramname">y</td><td>the current value of the simulation. </td></tr>
    <tr><td class="paramname">t</td><td>the current simulation time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector expression, same size as y, with the factor for each compartment. </dd></dl>

</div>
</div>
<a id="a836ec51b48f63ad6dca0724e9f5b28d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836ec51b48f63ad6dca0724e9f5b28d8">&#9670;&nbsp;</a></span>get_offset_in_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mio::get_offset_in_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmio_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmio_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the offset in days given two dates: first date minus second date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date1</td><td>first date. </td></tr>
    <tr><td class="paramname">date2</td><td>second date. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>offset in days between the two dates. </dd></dl>

</div>
</div>
<a id="ab14a93cf79d658750a62533c6c31d47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14a93cf79d658750a62533c6c31d47c">&#9670;&nbsp;</a></span>implement_dynamic_npis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DampingExprGroup , class MakeMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::implement_dynamic_npis </td>
          <td>(</td>
          <td class="paramtype">DampingExprGroup &amp;&#160;</td>
          <td class="paramname"><em>damping_expr_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmio_1_1DampingSampling.html">DampingSampling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>npis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1SimulationTime.html">SimulationTime</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1SimulationTime.html">SimulationTime</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MakeMatrix &amp;&amp;&#160;</td>
          <td class="paramname"><em>make_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>implement dynamic NPIs for a time span. </p>
<p>Adds or removes dampings to ensure that the active dampings during the specified time span is at least as big as the specified dynamic dampings. If another damping of the same type and level is active at the beginning of the time span or becomes active during the time span, the coefficient wise maximum of the new damping and the existing damping is used. At the end of the time span, another set of dampings may be added that restores the dampings on each level and type as they would have been without the dynamic npis that have just been implemented. Examples: a) no damping exists yet, dynamic npi of value <code>d</code>: one damping is added at the beginning of the time span that has the value <code>d</code>, another damping is added at the end of the time span that has a value zero. b) damping of value <code>a</code> is active before the beginning of the time span, dynamic npi of value <code>d</code> is added: one damping is added at the beginning of the time span that has the value <code>max(a, d)</code>, another damping is added at the end of the time span that has the value a b) damping of value <code>a</code> becomes active at a time <code>t_a</code> between the beginning of the time span and the end, dynamic npi of value <code>d</code> is added: one damping is added at the beginning of the time span that has the value <code>d</code>, the value of the damping at time <code>t_a</code> is set to <code>max(d, a)</code>, another damping is added at the end of the time span that has the value a </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">damping_expr_group</td><td>a group of matrix expressions that contains dampings, e.g. a <a class="el" href="classmio_1_1ContactMatrixGroup.html" title="represents a collection of contact frequency matrices that whose sum is the total number of contacts.">ContactMatrixGroup</a>. </td></tr>
    <tr><td class="paramname">dynamic_npis</td><td>the NPIs to be implemented </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the time span that the NPIs will be active for. </td></tr>
    <tr><td class="paramname">end</td><td>end of the time span that the NPIs will be active for. </td></tr>
    <tr><td class="paramname">make_matrix</td><td>function to make a matrix of the same shape as the damping expression, see e.g. make_contact_damping_matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe01e2795a0e0b69936834f050129964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe01e2795a0e0b69936834f050129964">&#9670;&nbsp;</a></span>insert_sorted_replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt;::iterator mio::insert_sorted_replace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af182124b02db89381844675d1365a286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af182124b02db89381844675d1365a286">&#9670;&nbsp;</a></span>insert_sorted_replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt;::iterator mio::insert_sorted_replace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts element in a sorted vector, replacing items that are equal precondition: elements in the vector are partially sorted and unique according the predicate postcondition: same as precondition, additionally contains exactly one element that is equal to item, order of other items is preserved </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>vector where item will be inserted </td></tr>
    <tr><td class="paramname">item</td><td>item to insert </td></tr>
    <tr><td class="paramname">pred</td><td>binary comparator, pred(item, a) returns true if item should go before element a, pred(a, item) returns true if element a should go before item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to inserted or replaced item in vec </dd></dl>

</div>
</div>
<a id="ae19cc9b7e5eb64f5ce5464de5511f737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19cc9b7e5eb64f5ce5464de5511f737">&#9670;&nbsp;</a></span>interpolate_ensemble_results()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacemio.html#a802f35511c350a60fbd8838a6df5bd61">InterpolateResultT</a>&lt;T&gt; &gt; mio::interpolate_ensemble_results </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ensemble_results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates results of all runs with evenly spaced, integer time points that represent whole days. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemio.html#a449f66b75f44f30dc4e70963355f9b5e" title="interpolate time series with evenly spaced, integer time points that represent whole days.">interpolate_simulation_result</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ensemble_result</td><td>result of multiple simulations (single <a class="el" href="classmio_1_1TimeSeries.html" title="stores vectors of values at time points (or some other abstract variable) the value at each time poin...">TimeSeries</a> or <a class="el" href="classmio_1_1Graph.html" title="generic graph structure">Graph</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated time series, one (or as many as nodes in the graph) per result in the ensemble </dd></dl>

</div>
</div>
<a id="a192b86ffbea1443e5fcdaaacce671227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192b86ffbea1443e5fcdaaacce671227">&#9670;&nbsp;</a></span>interpolate_simulation_result() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Simulation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt;double&gt; &gt; mio::interpolate_simulation_result </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; <a class="el" href="classmio_1_1Simulation.html">Simulation</a> &gt;, <a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph_result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>interpolate time series with evenly spaced, integer time points for each node. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemio.html#a449f66b75f44f30dc4e70963355f9b5e" title="interpolate time series with evenly spaced, integer time points that represent whole days.">interpolate_simulation_result</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph_result</td><td>graph of simulations whose results will be interpolated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one interpolated time series per node </dd></dl>

</div>
</div>
<a id="a449f66b75f44f30dc4e70963355f9b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449f66b75f44f30dc4e70963355f9b5e">&#9670;&nbsp;</a></span>interpolate_simulation_result() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; mio::interpolate_simulation_result </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>simulation_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>1e-14</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>interpolate time series with evenly spaced, integer time points that represent whole days. </p>
<p>time points [t0, t1, t2, ..., tmax] interpolated as days [ceil(t0), floor(t0) + 1,...,floor(tmax)]. tolerances in the first and last time point (t0 and t_max) are accounted for. values at new time points are linearly interpolated from their immediate neighbors from the old time points. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemio.html#a449f66b75f44f30dc4e70963355f9b5e" title="interpolate time series with evenly spaced, integer time points that represent whole days.">interpolate_simulation_result</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simulation_result</td><td>time series to interpolate </td></tr>
    <tr><td class="paramname">abs_tol</td><td>absolute tolerance given for doubles t0 and tmax to account for small deviations from whole days. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated time series </dd></dl>

</div>
</div>
<a id="a7dcfb78101db4f3634bad069f1e2271f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcfb78101db4f3634bad069f1e2271f">&#9670;&nbsp;</a></span>interpolate_simulation_result() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; mio::interpolate_simulation_result </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>simulation_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolation_times</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>interpolate time series with freely chosen time points that lie in between the time points of the given time series up to a given tolerance. </p>
<p>values at new time points are linearly interpolated from their immediate neighbors from the old time points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simulation_result</td><td>time series to interpolate </td></tr>
    <tr><td class="paramname">interpolations_times</td><td>std::vector of time points at which simulation results are interpolated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated time series at given interpolation points </dd></dl>

</div>
</div>
<a id="a46a8c32ccd44e57584abc88bf22eee11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a8c32ccd44e57584abc88bf22eee11">&#9670;&nbsp;</a></span>linear_interpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::linear_interpolation </td>
          <td>(</td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x_eval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear interpolation between two data values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x_eval</td><td>Location to evaluate interpolation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_1</td><td>Left node of interpolation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_2</td><td>Right node of interpolation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_1</td><td>Value at left node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_2</td><td>Value at right node. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unnamed</td><td>Interpolation result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a8e658f565465ae076eab415d976e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8e658f565465ae076eab415d976e1b">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220">LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdlog::string_view_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9760c798e6f1ea1678ca898d35f201a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9760c798e6f1ea1678ca898d35f201a6">&#9670;&nbsp;</a></span>log_debug()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::log_debug </td>
          <td>(</td>
          <td class="paramtype">spdlog::string_view_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89afc3ebfa2c5ab994ec3c76dcad85d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89afc3ebfa2c5ab994ec3c76dcad85d1">&#9670;&nbsp;</a></span>log_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::log_error </td>
          <td>(</td>
          <td class="paramtype">spdlog::string_view_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef6967891e4710c8a2305b434043c0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6967891e4710c8a2305b434043c0b2">&#9670;&nbsp;</a></span>log_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::log_info </td>
          <td>(</td>
          <td class="paramtype">spdlog::string_view_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaaa08ba47cc4a92310059cd08339a1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa08ba47cc4a92310059cd08339a1b9">&#9670;&nbsp;</a></span>log_rng_seeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mio::log_rng_seeds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmio_1_1RandomNumberGenerator.html">RandomNumberGenerator</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220">LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ff57ca749faaa72cd181e50bdd8d3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff57ca749faaa72cd181e50bdd8d3da">&#9670;&nbsp;</a></span>log_thread_local_rng_seeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mio::log_thread_local_rng_seeds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220">LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34f961d5004bf46cf1cee1133671f8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f961d5004bf46cf1cee1133671f8bc">&#9670;&nbsp;</a></span>log_warning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::log_warning </td>
          <td>(</td>
          <td class="paramtype">spdlog::string_view_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c57c15f2d7d146f3eba791912465106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c57c15f2d7d146f3eba791912465106">&#9670;&nbsp;</a></span>major_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index mio::major_size </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of rows (columns) of a row (column) major matrix. </p>

</div>
</div>
<a id="a4c9f267ac11fbfcb48a6642dbbd60dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9f267ac11fbfcb48a6642dbbd60dba">&#9670;&nbsp;</a></span>make_contact_damping_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::make_contact_damping_matrix </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>groups</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a contact damping matrix from dampings by group. </p>
<p>Maps a vector of dampings by group onto a contact damping matrix according to the formula d_ij = 1 - sqrt((1 - g_i) * (1 - g_j)) where d_ij is a coefficient of the matrix and g_i,g_j are coefficients of the group vector. For diagonal elements (i.e. contacts of group with itself): d_ii = g_i; the damping of the corresponding group is applied directly. For off diagonal elements (i.e. contacts of group with other group): d_ij between g_i and g_j; the dampings of both groups are combined and applied equally. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>damping value weighted by group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square matrix expression of damping coefficients. </dd></dl>

</div>
</div>
<a id="ad5befe24df9218b2206b79a49e9aba87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5befe24df9218b2206b79a49e9aba87">&#9670;&nbsp;</a></span>make_error_code() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::error_code&amp; mio::make_error_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmio_1_1IOStatus.html">IOStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <a class="el" href="classmio_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> to std::error_code. </p>
<p>Expected customization point of std::error_code. </p>

</div>
</div>
<a id="a531d453fb999299bf5437b66a2996d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531d453fb999299bf5437b66a2996d4b">&#9670;&nbsp;</a></span>make_error_code() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code mio::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a2799d348d433018d5b183d75bfbdd699">StatusCode</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert StatusCode to std::error_code. </p>
<p>Expected customization point of std::error_code. </p>

</div>
</div>
<a id="aa713d3a77fed175359840122fa6df9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa713d3a77fed175359840122fa6df9ba">&#9670;&nbsp;</a></span>make_graph_sim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph , class NodeF , class EdgeF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::make_graph_sim </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1Graph.html">Graph</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeF &amp;&amp;&#160;</td>
          <td class="paramname"><em>node_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeF &amp;&amp;&#160;</td>
          <td class="paramname"><em>edge_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82b6bb635d6376fc1886175c4f8e75d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b6bb635d6376fc1886175c4f8e75d3">&#9670;&nbsp;</a></span>make_graph_sim_stochastic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph , class NodeF , class EdgeF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::make_graph_sim_stochastic </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1Graph.html">Graph</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeF &amp;&amp;&#160;</td>
          <td class="paramname"><em>node_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeF &amp;&amp;&#160;</td>
          <td class="paramname"><em>edge_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad829a4e21b9bfa28bac6b3359a0c3cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad829a4e21b9bfa28bac6b3359a0c3cf3">&#9670;&nbsp;</a></span>make_migration_damping_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::make_migration_damping_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmio_1_1ColumnVectorShape.html">ColumnVectorShape</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make migration coefficient damping vector from dampings by group. </p>
<p>Maps the vector of dampings by group onto a migration coefficient damping vector [g_0, g_0, ..., g_1, g_1, ..., g_2, ...]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>shape (i.e. size) of the migration coefficient vector. </td></tr>
    <tr><td class="paramname">groups</td><td>damping value weighted by group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector expression of migration coefficient damping. </dd></dl>

</div>
</div>
<a id="a9afccd5e6410c704b1565079e5837d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afccd5e6410c704b1565079e5837d80">&#9670;&nbsp;</a></span>make_migration_sim() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmio_1_1GraphSimulation.html">GraphSimulation</a>&lt;<a class="el" href="classmio_1_1Graph.html">Graph</a>&lt;<a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt;Sim&gt;, <a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a>&gt; &gt; mio::make_migration_sim </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a migration simulation. </p>
<p>After every second time step, for each edge a portion of the population corresponding to the coefficients of the edge moves from one node to the other. In the next timestep, the migrated population return to their "home" node. Returns are adjusted based on the development in the target node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>start time of the simulation </td></tr>
    <tr><td class="paramname">dt</td><td>time step between migrations </td></tr>
    <tr><td class="paramname">graph</td><td>set up for migration simulation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a718336dfc617e9dbb8b7e1d29050861b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718336dfc617e9dbb8b7e1d29050861b">&#9670;&nbsp;</a></span>make_migration_sim() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmio_1_1GraphSimulationStochastic.html">GraphSimulationStochastic</a>&lt;<a class="el" href="classmio_1_1Graph.html">Graph</a>&lt;<a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt;Sim&gt;, <a class="el" href="classmio_1_1MigrationEdgeStochastic.html">MigrationEdgeStochastic</a>&gt; &gt; mio::make_migration_sim </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdgeStochastic.html">MigrationEdgeStochastic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a migration simulation. </p>
<p>After every second time step, for each edge a portion of the population corresponding to the coefficients of the edge moves from one node to the other. In the next timestep, the migrated population return to their "home" node. Returns are adjusted based on the development in the target node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>start time of the simulation </td></tr>
    <tr><td class="paramname">dt</td><td>time step between migrations </td></tr>
    <tr><td class="paramname">graph</td><td>set up for migration simulation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb7abb9f1e2b136f146af558abba7e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7abb9f1e2b136f146af558abba7e28">&#9670;&nbsp;</a></span>make_migration_sim() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmio_1_1GraphSimulation.html">GraphSimulation</a>&lt;<a class="el" href="classmio_1_1Graph.html">Graph</a>&lt;<a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt;Sim&gt;, <a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a>&gt; &gt; mio::make_migration_sim </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdge.html">MigrationEdge</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29ddabba17ee78ac0b4a3e380b9c4f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ddabba17ee78ac0b4a3e380b9c4f39">&#9670;&nbsp;</a></span>make_migration_sim() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmio_1_1GraphSimulationStochastic.html">GraphSimulationStochastic</a>&lt;<a class="el" href="classmio_1_1Graph.html">Graph</a>&lt;<a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt;Sim&gt;, <a class="el" href="classmio_1_1MigrationEdgeStochastic.html">MigrationEdgeStochastic</a>&gt; &gt; mio::make_migration_sim </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; <a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classmio_1_1MigrationEdgeStochastic.html">MigrationEdgeStochastic</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9874bbe82f7ecb6f7f6a00a55f2c2bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9874bbe82f7ecb6f7f6a00a55f2c2bbc">&#9670;&nbsp;</a></span>make_observer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmio_1_1observer__ptr.html">observer_ptr</a>&lt;T&gt; mio::make_observer </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a855a4c8ec365d7d6cc6e866b57ea2d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855a4c8ec365d7d6cc6e866b57ea2d1b">&#9670;&nbsp;</a></span>make_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter1 , class Iter2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::make_range </td>
          <td>(</td>
          <td class="paramtype">Iter1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>iter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>iter2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac160949c78aa17040a7b44c22754192b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac160949c78aa17040a7b44c22754192b">&#9670;&nbsp;</a></span>make_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterPair &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::make_range </td>
          <td>(</td>
          <td class="paramtype">IterPair &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>factories for template argument deduction </p>

</div>
</div>
<a id="a556fe87bb4d69609a931d684a863568c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556fe87bb4d69609a931d684a863568c">&#9670;&nbsp;</a></span>make_transform_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter , class Transform &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::make_transform_iterator </td>
          <td>(</td>
          <td class="paramtype">Iter &amp;&amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Transform &amp;&amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classmio_1_1TransformIterator.html" title="Iterator that transforms the values produced by an underlying iterator.">TransformIterator</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The underlying iterator. </td></tr>
    <tr><td class="paramname">transform</td><td>Instance of the transform functor. Default value is default constructed if possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69193b9fd2a0c3023d640082470a9ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69193b9fd2a0c3023d640082470a9ea0">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rng , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::map </td>
          <td>(</td>
          <td class="paramtype">const Rng &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a random access range (i.e. </p>
<p>anything with size() and operator[], e.g. std::vector) onto a Eigen array expression. Returns a column array expression a where a[i] = f(v[i]). The returned expression stores a reference to the range, lifetime of the range must exceed lifetime of the return. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a random access range. </td></tr>
    <tr><td class="paramname">f</td><td>a function that returns a numeric scalar for each element of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array expression a the same size as v where a[i] = f(v[i]). </dd></dl>

</div>
</div>
<a id="a97f6645c13faf4749f34d7e6e191f9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f6645c13faf4749f34d7e6e191f9ac">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::max </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>coefficient wise maximum of two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a matrix expression </td></tr>
    <tr><td class="paramname">b</td><td>a matrix expression of the same shape as a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix expression the shape of a with each coefficient the maximum of the coefficients of a and b. </dd></dl>

</div>
</div>
<a id="a2d9304db76fa4a82e64322fb206d956c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9304db76fa4a82e64322fb206d956c">&#9670;&nbsp;</a></span>minor_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index mio::minor_size </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of columns (rows) of a row (column) major matrix. </p>

</div>
</div>
<a id="abebb31121953c36c5b5b42976df8bcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebb31121953c36c5b5b42976df8bcad">&#9670;&nbsp;</a></span>offset_date_by_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmio_1_1Date.html">Date</a> mio::offset_date_by_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmio_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_days</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the new date corresponding to a given date and a offset in days. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>date. </td></tr>
    <tr><td class="paramname">offset_days</td><td>offset in days. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new date that is date + offset_days. </dd></dl>

</div>
</div>
<a id="a1c9249591dc1922dcbff6ebb7746bee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9249591dc1922dcbff6ebb7746bee7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacemio.html#af8c639c34c4df5647f084fefb48afc6e">has_eq_op</a>&lt;T&gt;::value, bool&gt; mio::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5af4730337dd5d430e3d09e4a88c09b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af4730337dd5d430e3d09e4a88c09b5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacemio.html#af8c639c34c4df5647f084fefb48afc6e">has_eq_op</a>&lt;T&gt;::value, bool&gt; mio::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmio_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmio_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a58db8b765e525595174fe5b502bf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a58db8b765e525595174fe5b502bf85">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespacemio.html#a828f9a1016d1048d5d3e67dcc5ff4e8f">has_ostream_op</a>&lt;T&gt;::value, std::ostream&amp;&gt; mio::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>out stream operator for edges if edge property type does not have stream operator defined </p>

</div>
</div>
<a id="a5b8d13d4bfbc6ab42cccb685cafdc5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8d13d4bfbc6ab42cccb685cafdc5fe">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacemio.html#a828f9a1016d1048d5d3e67dcc5ff4e8f">has_ostream_op</a>&lt;T&gt;::value, std::ostream&amp;&gt; mio::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>out stream operator for edges if edge property type has stream operator defined </p>

</div>
</div>
<a id="a2d44315af9f65cbb43ea90af7f1fae30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d44315af9f65cbb43ea90af7f1fae30">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacemio.html#af8c639c34c4df5647f084fefb48afc6e">has_eq_op</a>&lt;T&gt;::value, bool&gt; mio::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmio_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>comparison operator if edge property type is equality comparable </p>

</div>
</div>
<a id="abf5eed69a2714509b05344ebd743543e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5eed69a2714509b05344ebd743543e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacemio.html#af8c639c34c4df5647f084fefb48afc6e">has_eq_op</a>&lt;T&gt;::value, bool&gt; mio::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmio_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmio_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>comparison operator if node property type is equality comparable </p>

</div>
</div>
<a id="a8630d8af93b95cc04f1f60ec774a425b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8630d8af93b95cc04f1f60ec774a425b">&#9670;&nbsp;</a></span>parse_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt;<a class="el" href="structmio_1_1Date.html">Date</a>&gt; mio::parse_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>date_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses a date from a string. </p>
<p>uses fixed format YYYY.MM.DD or YYYY-MM-DD. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_str</td><td>date as a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed date. </dd></dl>

</div>
</div>
<a id="ad5d271b1fc1bc5f9ef54eb91c695f239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d271b1fc1bc5f9ef54eb91c695f239">&#9670;&nbsp;</a></span>path_join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class String , class... Strings&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string mio::path_join </td>
          <td>(</td>
          <td class="paramtype">String &amp;&amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Strings &amp;&amp;...&#160;</td>
          <td class="paramname"><em>app</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>join one ore more strings with path separators. </p>
<p>Accepts mixed C strings or std::strings.</p>
<p>example: </p><pre class="fragment">std::string hello("Hello");
auto p = path_join(hello, "World"); //returns "Hello/World"
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>first string </td></tr>
    <tr><td class="paramname">app</td><td>zero or more other strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>all inputs joined </dd></dl>

</div>
</div>
<a id="a48fb690ce687ea46e1d39decd0256e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fb690ce687ea46e1d39decd0256e71">&#9670;&nbsp;</a></span>print_graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::print_graph </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmio_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeff056f6334958caaeb57f839f718c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff056f6334958caaeb57f839f718c23">&#9670;&nbsp;</a></span>print_graph_object() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespacemio.html#a828f9a1016d1048d5d3e67dcc5ff4e8f">has_ostream_op</a>&lt;T&gt;::value, void&gt; mio::print_graph_object </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51670ce4ee6cf980fa675af2076a6da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51670ce4ee6cf980fa675af2076a6da7">&#9670;&nbsp;</a></span>print_graph_object() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacemio.html#a828f9a1016d1048d5d3e67dcc5ff4e8f">has_ostream_op</a>&lt;T&gt;::value, void&gt; mio::print_graph_object </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac88d8b5328998d7bd587ee9fdb01264b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88d8b5328998d7bd587ee9fdb01264b">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mio::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmio_1_1IOStatus.html">IOStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gtest printer for <a class="el" href="classmio_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a>. </p>

</div>
</div>
<a id="af925d286771dec772a63ca778c022ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af925d286771dec772a63ca778c022ff4">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mio::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmio_1_1UncertainValue.html">UncertainValue</a> &amp;&#160;</td>
          <td class="paramname"><em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeec62c6bfbabd61f08d7653ad015019b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec62c6bfbabd61f08d7653ad015019b">&#9670;&nbsp;</a></span>read_mobility_formatted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; Eigen::MatrixXd &gt; mio::read_mobility_formatted </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads formatted migration or contact data which is given in columns from_str to_str from_rs to_rs count_abs and separated by tabs. </p>
<p>Writes it into a NxN Eigen Matrix, where N is the number of regions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of file to be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9a8796a9d01a72a28ac34b1aa1332b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a8796a9d01a72a28ac34b1aa1332b4">&#9670;&nbsp;</a></span>read_mobility_plain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt; Eigen::MatrixXd &gt; mio::read_mobility_plain </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads txt migration data or contact which is given by values only and separated by spaces. </p>
<p>Writes it into a NxN Eigen Matrix, where N is the number of regions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of file to be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cd64a3ccb4b0435e7de0f3afef289ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd64a3ccb4b0435e7de0f3afef289ea">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::reshape </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reshape the matrix. </p>
<p>Total number of entries before and after the reshape must be the same. The new matrix shares memory with the input matrix, no copying is performed, changes to the new matrix will be made to the input matrix as well. Assign to another matrix of compatible size if you need a copy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>matrix to reshape </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows of the new matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of cols of the new matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>matrix expression with the same entries as the input matrix but new shape </dd></dl>

</div>
</div>
<a id="afa85830d7050b8ecdc6d2ae664b74290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa85830d7050b8ecdc6d2ae664b74290">&#9670;&nbsp;</a></span>result_distance_2norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mio::result_distance_2norm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">mio::TimeSeries</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>result1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">mio::TimeSeries</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>result2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the distance between two SECIR simulation results. </p>
<p>The distance is the 2-norm of the element-wise difference of the two results. The two results (e.g. output of interpolate_simulation_result) must have the same dimensions and number of time points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result1</td><td>first result. </td></tr>
    <tr><td class="paramname">result2</td><td>second result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Computed distance between result1 and result2. </dd></dl>

</div>
</div>
<a id="a721ec86366e54b94f1d34bfbf6c8a806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721ec86366e54b94f1d34bfbf6c8a806">&#9670;&nbsp;</a></span>result_distance_2norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InfectionState &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mio::result_distance_2norm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">mio::TimeSeries</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>result1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">mio::TimeSeries</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>result2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InfectionState&#160;</td>
          <td class="paramname"><em>compartment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the distance between two compartment model simulation results in one compartment. </p>
<p>The distance is the 2-norm of the element-wise difference of the two results in the specified compartment. The two results (e.g. output of interpolate_simulation_result) must have the same dimensions and number of time points. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InfectionState</td><td>enum type that defines the compartments of the model that produced the results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result1</td><td>first result. </td></tr>
    <tr><td class="paramname">result2</td><td>second result. </td></tr>
    <tr><td class="paramname">compartment</td><td>the compartment to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Computed distance between result1 and result2. </dd></dl>

</div>
</div>
<a id="a27a24b9e6cb629e04e9613446f07d6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a24b9e6cb629e04e9613446f07d6ba">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::serialize </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save data that describes an object in a format determined by the given context. </p>
<p>There must be provided for the type T either a free function <code>serialize_internal(io, t)</code> that can be found using argument dependent lookup (ADL) or a member function <code>t.serialize(io)</code>. The <code>serialize_internal</code> function or <code>serialize</code> member function provide the data that describes the object to the io context. The context stores the data in some unspecified format so that the objects can be reconstructed from it. The context also keeps track of any IO errors. <code>serialize_internal</code> overloads are already provided for many common types, e.g. STL containers or Eigen Matrices. <code>serialize</code> and <code>deserialize</code> are the main entry point into this IO framework, but there may be more convenient functions provided for specific IO contexts. These functions are not expected to use ADL, so should be called namespace qualified. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">T</td><td>any serializable type, i.e., that has a <code>serialize</code> member function or <code>serialize_internal</code> overload </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>io context that stores data from the object t in some unspecified format. </td></tr>
    <tr><td class="paramname">t</td><td>the object to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a960fc458f9dc3a8a39e13a54735dcdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960fc458f9dc3a8a39e13a54735dcdee">&#9670;&nbsp;</a></span>serialize_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmio_1_1ByteStream.html">ByteStream</a> mio::serialize_binary </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize an object into binary format. </p>
<p>The format is not portable, object must be deserialized by the same (or identically compiled) program. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classmio_1_1ByteStream.html" title="In-memory stream of bytes.">ByteStream</a> that contains the serialized bytes that represent the object. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the object to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad073fd426ea5971baa4f6959f1244d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad073fd426ea5971baa4f6959f1244d0e">&#9670;&nbsp;</a></span>serialize_internal() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class Container , std::enable_if_t&lt; conjunction_v&lt; is_container&lt; Container &gt;, negation&lt; has_serialize&lt; IOContext, Container &gt;&gt;&gt;, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::serialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize an STL compatible container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">Container</td><td>the container type to be serialized. A container is anything with begin and end iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">container</td><td>a container to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a123611af57e5e17defecde4498b0a25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123611af57e5e17defecde4498b0a25c">&#9670;&nbsp;</a></span>serialize_internal() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::serialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::EigenBase&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize an Eigen matrix expression. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">M</td><td>the type of Eigen matrix expression to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">mat</td><td>the matrix expression to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17c89be42d282d1da23ce443c09e9e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c89be42d282d1da23ce443c09e9e74">&#9670;&nbsp;</a></span>serialize_internal() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T , std::enable_if_t&lt; is_expression_valid&lt; serialize_t, IOContext, T &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::serialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize an object that has a serialize(io) member function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">T</td><td>the Type of the object to be serialized. Must have a serialize member function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context </td></tr>
    <tr><td class="paramname">t</td><td>the object to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f158d720a7cadd39e482f6c2302a087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f158d720a7cadd39e482f6c2302a087">&#9670;&nbsp;</a></span>serialize_internal() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class Tup , class  = std::enable_if_t&lt;is_expression_valid&lt;details::tuple_size_value_t, Tup&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::serialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tup &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize a tuple-like object, e.g. </p>
<p>std::tuple or std::pair. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">Tup</td><td>the tuple-like type to be serialized, i.e. anything that supports tuple_size and tuple_element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">tup</td><td>a tuple-like object to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6e3cf3f2cc4c651d581573f57331229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e3cf3f2cc4c651d581573f57331229">&#9670;&nbsp;</a></span>serialize_internal() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class E , std::enable_if_t&lt; std::is_enum&lt; E &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::serialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize an enum value as its underlying type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">E</td><td>an enum type to be serialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context </td></tr>
    <tr><td class="paramname">e</td><td>an enum value to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f42fd4fd378be54e349ec0043efeb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f42fd4fd378be54e349ec0043efeb1d">&#9670;&nbsp;</a></span>set_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContactLocation , class Model , class MigrationParams , class MigrationCoefficientGroup , class InfectionState , class ReadFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt;void&gt; mio::set_edges </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>data_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; Model, MigrationParams &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; InfectionState &gt; &amp;&#160;</td>
          <td class="paramname"><em>migrating_compartments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>contact_locations_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>read_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="config_8h.html#acd4f1d492d83a74716a42615e127d641">ScalarType</a> &gt;&#160;</td>
          <td class="paramname"><em>commuting_weights</em> = <code>std::vector&lt;<a class="el" href="config_8h.html#acd4f1d492d83a74716a42615e127d641">ScalarType</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the graph edges. </p>
<p>Reads the commuting matrices from txt files and sets the graph edges with that. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_dir</td><td>Directory that contains the data files. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">params_graph</td><td><a class="el" href="classmio_1_1Graph.html" title="generic graph structure">Graph</a> whose nodes are set by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">migrating_compartments</td><td>Compartments that commute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contact_locations_size</td><td>Number of contact locations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_func</td><td>Function that reads commuting matrices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commuting_weights</td><td>Vector with a commuting weight for every <a class="el" href="structmio_1_1AgeGroup.html" title="The AgeGroup struct is used as a dynamically sized tag for all age dependent categories.">AgeGroup</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac76d1d8f469ab547ed1ceb5e8c96f271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76d1d8f469ab547ed1ceb5e8c96f271">&#9670;&nbsp;</a></span>set_log_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mio::set_log_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemio.html#a67881790c6dfd8c058d27e5f1fe24220">LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the verbosity of the logger. </p>

</div>
</div>
<a id="a62370f41f294bb6b3a1f32fc7a37473c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62370f41f294bb6b3a1f32fc7a37473c">&#9670;&nbsp;</a></span>set_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TestAndTrace , class ContactPattern , class Model , class MigrationParams , class Parameters , class ReadFunction , class NodeIdFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemio.html#ae556a666d14183eb2bf3a3efc11551ec">IOResult</a>&lt;void&gt; mio::set_nodes </td>
          <td>(</td>
          <td class="paramtype">const Parameters &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmio_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>start_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmio_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>end_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>data_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>population_data_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_node_for_county</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmio_1_1Graph.html">Graph</a>&lt; Model, MigrationParams &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>read_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeIdFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>node_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factor_inf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaling_factor_icu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tnt_capacity_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_days</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>export_time_series</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the graph nodes for counties or districts. </p>
<p>Reads the node ids which could refer to districts or counties and the epidemiological data from json files and creates one node for each id. Every node contains a model. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Model Parameters that are used for every node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_date</td><td>Start date for which the data should be read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_data</td><td>End date for which the data should be read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_dir</td><td>Directory that contains the data files. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">population_data_path</td><td>Path to json file containing the population data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_node_for_county</td><td>Specifies whether the node ids should be county ids (true) or district ids (false). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">params_graph</td><td><a class="el" href="classmio_1_1Graph.html" title="generic graph structure">Graph</a> whose nodes are set by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_func</td><td>Function that reads input data for german counties and sets Model compartments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node_func</td><td>Function that returns the county ids. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaling_factor_inf</td><td>Factor of confirmed cases to account for undetected cases in each county. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaling_factor_icu</td><td>Factor of ICU cases to account for underreporting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tnt_capacity_factor</td><td>Factor for test and trace capacity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_days</td><td>Number of days to be simulated; required to load data for vaccinations during the simulation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">export_time_series</td><td>If true, reads data for each day of simulation and writes it in the same directory as the input files. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf026dd6066d8d0e413fb754082a2dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf026dd6066d8d0e413fb754082a2dd2">&#9670;&nbsp;</a></span>simulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Model , class Sim  = Simulation&lt;Model&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt;<a class="el" href="config_8h.html#acd4f1d492d83a74716a42615e127d641">ScalarType</a>&gt; mio::simulate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model const &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmio_1_1IntegratorCore.html">IntegratorCore</a> &gt;&#160;</td>
          <td class="paramname"><em>integrator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simulate simulates a compartmental model </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t0</td><td>start time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmax</td><td>end time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>initial step size of integration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>An instance of a compartmental model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classmio_1_1TimeSeries.html" title="stores vectors of values at time points (or some other abstract variable) the value at each time poin...">TimeSeries</a> to represent the final simulation result </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Model</td><td>a compartment model type </td></tr>
    <tr><td class="paramname">Sim</td><td>a simulation type that can simulate the model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad68521b3c371e12d598418900b3049d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad68521b3c371e12d598418900b3049d">&#9670;&nbsp;</a></span>slice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , std::enable_if_t&lt; is_dynamic_matrix&lt; M &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::slice </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmio_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmio_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take a regular slice of a matrix. </p>
<p>The slices shares the same memory as the original matrix, no copying is performed, changes to the slice are also made to the original matrix. Assign to a different matrix of compatible size if you need a copy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix to take a slice of </td></tr>
    <tr><td class="paramname">rows</td><td>sequence of row indices </td></tr>
    <tr><td class="paramname">cols</td><td>sequence of column indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>matrix expression with selected entries from the input matrix </dd></dl>

</div>
</div>
<a id="a743eeec3a91821cb14fd831740b17827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743eeec3a91821cb14fd831740b17827">&#9670;&nbsp;</a></span>slice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , std::enable_if_t&lt; is_dynamic_vector&lt; V &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::slice </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmio_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt;&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take a regular slice of a row or column vector. </p>
<p>The slices shares the same memory as the original vector, no copying is performed, changes to the slice are also made to the original vector. Assign to a different vector of compatible size if you need a copy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Row or column vector to take a slice of </td></tr>
    <tr><td class="paramname">elems</td><td>sequence of row or column indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector expression with selected entries from the input vector </dd></dl>

</div>
</div>
<a id="a73ea68c2bc0b216f8ffeb9c5a53ea49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ea68c2bc0b216f8ffeb9c5a53ea49a">&#9670;&nbsp;</a></span>smoother_cosine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LeftExpr , class RightExpr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::smoother_cosine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xright</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; LeftExpr &gt; &amp;&#160;</td>
          <td class="paramname"><em>yleft_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; RightExpr &gt; &amp;&#160;</td>
          <td class="paramname"><em>yright_expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smoother_cosine as a matrix valued function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>evaluation point </td></tr>
    <tr><td class="paramname">xleft</td><td>left boundary x </td></tr>
    <tr><td class="paramname">xright</td><td>right boundary x </td></tr>
    <tr><td class="paramname">yleft</td><td>matrix expression, function value at left boundary </td></tr>
    <tr><td class="paramname">yright</td><td>matrix expression, function value at right boundary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix expression with yij = smoother_cosine(x, xleft, xright, yleftij, yrightij) </dd></dl>

</div>
</div>
<a id="a472d6437e9b34e277b8ccc551b0630b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472d6437e9b34e277b8ccc551b0630b8">&#9670;&nbsp;</a></span>smoother_cosine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mio::smoother_cosine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xright</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smoothed evaluation of a discrete jump of function values <br  />
 yleft and yright on xleft and xright, respectively, by using a cosine function. </p>
<p>If the input value is outside the given interval, yleft or yright are returned, respectively. { yleft, for x &lt;= xleft f(x) = { yright, for x &gt;= xright { 0.5*(yleft - yright)*cos(pi/(xright-xleft)*(x-xleft))+0.5*(yleft + yright) for x\in[xleft,xright] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>current evaluation point </td></tr>
    <tr><td class="paramname">xleft</td><td>left boundary of independent variable </td></tr>
    <tr><td class="paramname">xright</td><td>right boundary of independent variable </td></tr>
    <tr><td class="paramname">yleft</td><td>function value at left boundary </td></tr>
    <tr><td class="paramname">yright</td><td>function value at right boundary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double cosine-smoothed evaluation of discrete step function </dd></dl>

</div>
</div>
<a id="aa5d968bb8ec90f4bdbf8bfbee2a98ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d968bb8ec90f4bdbf8bfbee2a98ccb">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; mio::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits string into a Vector of strings according to delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string which is splitted </td></tr>
    <tr><td class="paramname">delimiter</td><td>sign at which to split string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3a4eb6dbb5992d29976faefcdd5b78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a4eb6dbb5992d29976faefcdd5b78c">&#9670;&nbsp;</a></span>status_code_category()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmio_1_1detail_1_1StatusCodeCategory.html">detail::StatusCodeCategory</a>&amp; mio::status_code_category </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>singleton StatusCodeCategory instance. </p>

</div>
</div>
<a id="a80d7fd30c9669e05b537b2caedd82bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d7fd30c9669e05b537b2caedd82bb8">&#9670;&nbsp;</a></span>success() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto mio::success </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object that is implicitly convertible to a succesful IOResult&lt;void&gt;. </p>
<p>Use <code>return <a class="el" href="namespacemio.html#a80d7fd30c9669e05b537b2caedd82bb8" title="Create an object that is implicitly convertible to a succesful IOResult&lt;void&gt;.">success()</a></code> to conveniently return a successful result from a function. </p>

</div>
</div>
<a id="a98cc59d9b2500df07a248ff1fd2b7367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cc59d9b2500df07a248ff1fd2b7367">&#9670;&nbsp;</a></span>success() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mio::success </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object that is implicitly convertible to a succesful IOResult. </p>
<p>Use <code>return success(t)</code> to conveniently return a successful result from a function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>a value that is convertible to the value type of the IOResult </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bc993280be5018864892fb24b3e9f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc993280be5018864892fb24b3e9f18">&#9670;&nbsp;</a></span>sum_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt; &gt; mio::sum_nodes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classmio_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ensemble_result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb526164db4b433fe9e65133f20edd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb526164db4b433fe9e65133f20edd3d">&#9670;&nbsp;</a></span>test_commuters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim , std::enable_if_t&lt;!is_expression_valid&lt; test_commuters_expr_t, Sim &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::test_commuters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmio_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>migrated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test persons when migrating from their source node. </p>
<p>May transfer persons between compartments, e.g., if an infection was detected. This feature is optional, default implementation does nothing. In order to support this feature for your model, implement a test_commuters overload that can be found with argument-dependent lookup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a node of a migration graph. </td></tr>
    <tr><td class="paramname">migrated</td><td>mutable reference to vector of persons per compartment that migrate. </td></tr>
    <tr><td class="paramname">t</td><td>the current simulation time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39d12da511334eeca8b76dda616efd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d12da511334eeca8b76dda616efd25">&#9670;&nbsp;</a></span>thread_local_rng()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmio_1_1RandomNumberGenerator.html">RandomNumberGenerator</a> &amp; mio::thread_local_rng </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a random number generator that is static and local to this thread. </p>
<dl class="section return"><dt>Returns</dt><dd>a random number generator that is static and local to this thread. </dd></dl>

</div>
</div>
<a id="a9fab9e6d67aeaa98bb74dac0d52ac4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fab9e6d67aeaa98bb74dac0d52ac4fc">&#9670;&nbsp;</a></span>unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mio::unused </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does nothing, can be used to mark variables as not used. </p>
<p>e.g. for avoiding compiler warnings/error about unused variables. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5e1169fe9e5d36e1c3a2bf558a874049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1169fe9e5d36e1c3a2bf558a874049">&#9670;&nbsp;</a></span>conjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mio::conjunction_v = <a class="el" href="structmio_1_1conjunction.html">conjunction</a>&lt;Bs...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a051882939b25c74a4d3fd2cad852a942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051882939b25c74a4d3fd2cad852a942">&#9670;&nbsp;</a></span>disjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Bn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mio::disjunction_v = <a class="el" href="structmio_1_1disjunction.html">disjunction</a>&lt;Bn...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12844b1c358ec3b74eba28dc795087fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12844b1c358ec3b74eba28dc795087fd">&#9670;&nbsp;</a></span>negation_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Trait &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mio::negation_v = <a class="el" href="structmio_1_1negation.html">negation</a>&lt;Trait&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
