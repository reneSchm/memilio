<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEmilio: memilio.epidata.modifyDataframeSeries Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MEmilio
   &#160;<span id="projectnumber">0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>memilio</b></li><li class="navelem"><a class="el" href="namespacememilio_1_1epidata.html">epidata</a></li><li class="navelem"><a class="el" href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html">modifyDataframeSeries</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">memilio.epidata.modifyDataframeSeries Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a17570113b7b17fd5b16cadb16634b204"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#a17570113b7b17fd5b16cadb16634b204">create_intervals_mapping</a> (from_lower_bounds, to_lower_bounds)</td></tr>
<tr class="memdesc:a17570113b7b17fd5b16cadb16634b204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mapping from given intervals to new desired intervals.  <a href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#a17570113b7b17fd5b16cadb16634b204">More...</a><br /></td></tr>
<tr class="separator:a17570113b7b17fd5b16cadb16634b204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe568d90d62bbeb5a8bb9cc7c740621e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#abe568d90d62bbeb5a8bb9cc7c740621e">extract_subframe_based_on_dates</a> (df, start_date, end_date)</td></tr>
<tr class="memdesc:abe568d90d62bbeb5a8bb9cc7c740621e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all data with date lower than start date or higher than end date.  <a href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#abe568d90d62bbeb5a8bb9cc7c740621e">More...</a><br /></td></tr>
<tr class="separator:abe568d90d62bbeb5a8bb9cc7c740621e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e283eccc0c89ea24eedecbe4992ca38"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#a2e283eccc0c89ea24eedecbe4992ca38">fit_age_group_intervals</a> (df_age_in, age_out, df_population=None, max_age=100)</td></tr>
<tr class="memdesc:a2e283eccc0c89ea24eedecbe4992ca38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mapping from given intervals to new desired intervals.  <a href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#a2e283eccc0c89ea24eedecbe4992ca38">More...</a><br /></td></tr>
<tr class="separator:a2e283eccc0c89ea24eedecbe4992ca38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9ee11a9567c103abfbba3376d29235"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#a6c9ee11a9567c103abfbba3376d29235">impute_and_reduce_df</a> (df_old, group_by_cols, mod_cols, impute='forward', moving_average=0, min_date='', max_date='', start_w_firstval=False)</td></tr>
<tr class="memdesc:a6c9ee11a9567c103abfbba3376d29235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impute missing dates of dataframe time series and optionally calculates a moving average of the data.  <a href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#a6c9ee11a9567c103abfbba3376d29235">More...</a><br /></td></tr>
<tr class="separator:a6c9ee11a9567c103abfbba3376d29235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5e314e012fab4bce45a073e98d5174"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#a6f5e314e012fab4bce45a073e98d5174">insert_column_by_map</a> (df, col_to_map, new_col_name, map)</td></tr>
<tr class="memdesc:a6f5e314e012fab4bce45a073e98d5174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a column to a given dataframe based on a mapping of values of a given column.  <a href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#a6f5e314e012fab4bce45a073e98d5174">More...</a><br /></td></tr>
<tr class="separator:a6f5e314e012fab4bce45a073e98d5174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96264f9bbf171a696b5d08f504505e4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#a96264f9bbf171a696b5d08f504505e4e">split_column_based_on_values</a> (df_to_split, column_to_split, column_vals_name, groupby_list, column_identifiers_to_names_dict, compute_cumsum)</td></tr>
<tr class="memdesc:a96264f9bbf171a696b5d08f504505e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a column in a dataframe into separate columns.  <a href="namespacememilio_1_1epidata_1_1modifyDataframeSeries.html#a96264f9bbf171a696b5d08f504505e4e">More...</a><br /></td></tr>
<tr class="separator:a96264f9bbf171a696b5d08f504505e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a17570113b7b17fd5b16cadb16634b204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17570113b7b17fd5b16cadb16634b204">&#9670;&nbsp;</a></span>create_intervals_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def memilio.epidata.modifyDataframeSeries.create_intervals_mapping </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>from_lower_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>to_lower_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a mapping from given intervals to new desired intervals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_lower_bounds</td><td>lower bounds of original intervals </td></tr>
    <tr><td class="paramname">to_lower_bounds</td><td>desired lower bounds of new intervals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mapping from intervals to intervals The mapping is given as a list of tupels for every original interval. The list contains a tuple for every new interval intersecting the original interval. Each tuple defines the share of the original interval that is mapped to the new interval and the index of the new interval. We assume that the range of the intervals mapped from is contained in the range of the intervals mapped to. For example for from_lower_bounds = [5,20,30,80,85,90] and to_lower_bounds=[0,15,20,60,100] given the mapping would be [[[2/3,0], [1/3,1]], [[1,2]], [[3/5,2], [2/5,3]], [[1,3]], [[1,3]]] </dd></dl>

</div>
</div>
<a id="abe568d90d62bbeb5a8bb9cc7c740621e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe568d90d62bbeb5a8bb9cc7c740621e">&#9670;&nbsp;</a></span>extract_subframe_based_on_dates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def memilio.epidata.modifyDataframeSeries.extract_subframe_based_on_dates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end_date</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all data with date lower than start date or higher than end date. </p>
<p>Returns the Dataframe with only dates between start date and end date. Resets the Index of the Dataframe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">df</td><td>The dataframe which has to be edited </td></tr>
    <tr><td class="paramname">start_date</td><td>Date of first date in dataframe </td></tr>
    <tr><td class="paramname">end_date</td><td>Date of last date in dataframe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a dataframe with the extracted dates </dd></dl>

</div>
</div>
<a id="a2e283eccc0c89ea24eedecbe4992ca38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e283eccc0c89ea24eedecbe4992ca38">&#9670;&nbsp;</a></span>fit_age_group_intervals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def memilio.epidata.modifyDataframeSeries.fit_age_group_intervals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df_age_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>age_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df_population</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_age</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a mapping from given intervals to new desired intervals. </p>
<p>Provide all intervals as "x-y". Boundary age groups can be provided with "&lt;x" or "&gt;y". Minimum and maximum are then taken as 0 and 99, respectively. Example: If df_population is set, we can use this data set to best interpolate @df_age_in to the desired age stratification of @age_out. Where this data is not finely enough resolved or if this data set is not provided, we assume the population to be equally distributed. Ex. df_age_in = ["1-10": 4, "11-60": 10, "61-99": 8] age_out = ["1-5", "6-10", "11-50", "51-99"] returns ["1-5": 2, "6-10": 2, "11-50": 8, "51-99": 10] if no population data is provided.</p>
<p>If we also provide the population data population = ["1-5": 40, "6-7": 5, "8-10": 5, "11-60": 25, "61-99": 25], The output is: ["1-5": 3.2, "6-10": 0.8, "11-50": 8., "51:99": 10.]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">df_age_in</td><td>Dataframe with columns of different age intervals and one row for subpopulation sizes for an arbitrary feature. </td></tr>
    <tr><td class="paramname">age_out</td><td>Desired age group distribution in list of strings. </td></tr>
    <tr><td class="paramname">df_population</td><td>Total population data of the same structure as df_age_in used to inter- or extrapolate date of @df_age_in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Subpopulations of @df_age_in inter- or extrapolated to age stratification as required by @age_out. </dd></dl>

</div>
</div>
<a id="a6c9ee11a9567c103abfbba3376d29235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9ee11a9567c103abfbba3376d29235">&#9670;&nbsp;</a></span>impute_and_reduce_df()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def memilio.epidata.modifyDataframeSeries.impute_and_reduce_df </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>group_by_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mod_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>impute</em> = <code>'forward'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>moving_average</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_date</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_date</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start_w_firstval</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impute missing dates of dataframe time series and optionally calculates a moving average of the data. </p>
<p>Extracts Dates between min and max date.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">df_old</td><td>old pandas dataframe </td></tr>
    <tr><td class="paramname">group_by_cols</td><td>Column names for grouping by and items of particular group specification (e.g., for region: list of county oder federal state IDs) </td></tr>
    <tr><td class="paramname">mod_cols</td><td>List of columns for which the imputation and/or moving average is conducted (e.g., Confirmed or ICU) </td></tr>
    <tr><td class="paramname">impute</td><td>[Default: 'forward'] imputes either based on older values ('forward') or zeros ('zeros') </td></tr>
    <tr><td class="paramname">moving_average</td><td>[Default: 0, no averaging] Number of days over which to compute the moving average </td></tr>
    <tr><td class="paramname">min_date</td><td>[Default: '', taken from df_old] If set, minimum date to be set in new data frame for all items in group_by </td></tr>
    <tr><td class="paramname">max_date</td><td>[Default: '', taken from df_old] If set, maximum date to be set in new data frame for all items in group_by </td></tr>
    <tr><td class="paramname">start_w_firstval</td><td>[Default: False] If True and min_date &lt; first date in dataframe, then between min_date and first date, the value of the first date will be repeated backwards. If False, then zero is set there. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dataframe with imputed dates (and moving average if requested) </dd></dl>

</div>
</div>
<a id="a6f5e314e012fab4bce45a073e98d5174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5e314e012fab4bce45a073e98d5174">&#9670;&nbsp;</a></span>insert_column_by_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def memilio.epidata.modifyDataframeSeries.insert_column_by_map </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>col_to_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a column to a given dataframe based on a mapping of values of a given column. </p>
<p>The mapping is defined by a list containing tupels of the form (new_value, old_value) where old_value is a value in the col_to_map and new_value the value that is added in the new column if col_to_map contains the old_value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">df</td><td>dataframe to modify </td></tr>
    <tr><td class="paramname">col_to_map</td><td>column containing values to be mapped </td></tr>
    <tr><td class="paramname">new_col_name</td><td>name of the new column containing the mapped values </td></tr>
    <tr><td class="paramname">map</td><td>List of tuples of values in the column to be added and values in the given column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dataframe df with column of state names correspomding to state ids </dd></dl>

</div>
</div>
<a id="a96264f9bbf171a696b5d08f504505e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96264f9bbf171a696b5d08f504505e4e">&#9670;&nbsp;</a></span>split_column_based_on_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def memilio.epidata.modifyDataframeSeries.split_column_based_on_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df_to_split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>column_to_split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>column_vals_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>groupby_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>column_identifiers_to_names_dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_cumsum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a column in a dataframe into separate columns. </p>
<p>For each unique value that appears in a selected column, all corresponding values in another column are transfered to a new column. If required, cumulative sum is calculated in new generated columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">df_to_split</td><td>global pandas dataframe </td></tr>
    <tr><td class="paramname">column_to_split</td><td>identifier of the column for which separate values will define separate dataframes </td></tr>
    <tr><td class="paramname">column_vals_name</td><td>The name of the original column which will be split into separate columns named according to new_column_labels. </td></tr>
    <tr><td class="paramname">groupby_list</td><td>The name of the original columns with which data of new_column_labels can be joined. </td></tr>
    <tr><td class="paramname">column_identifiers_to_names_dict</td><td>Dict for new labels of resulting columns. </td></tr>
    <tr><td class="paramname">compute_cumsum</td><td>Computes cumulative sum in new generated columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a dataframe with the new splitted columns </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
